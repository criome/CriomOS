(defun read-file (V2782) (let Bytelist (read-file-as-bytelist V2782) (let S-exprs (trap-error (compile (lambda X (shen.<s-exprs> X)) Bytelist) (lambda E (shen.print-residue (value shen.*residue*)))) (let Process (shen.process-sexprs S-exprs) Process))))

(defun shen.print-residue (V2783) (let Err (pr "syntax error here:
" (stoutput)) (shen.nchars 50 V2783)))

(defun shen.nchars (V2788 V2789) (cond ((= 0 V2788) (do (pr " ..." (stoutput)) (abort))) ((= () V2789) (do (pr " ..." (stoutput)) (abort))) ((cons? V2789) (do (pr (n->string (hd V2789)) (stoutput)) (shen.nchars (- V2788 1) (tl V2789)))) (true (shen.f-error shen.nchars))))

(defun it () (value shen.*it*))

(defun read-file-as-bytelist (V2790) (let Stream (open V2790 in) (let Byte (read-byte Stream) (let Bytes (shen.read-file-as-bytelist-help Stream Byte ()) (let Close (close Stream) (reverse Bytes))))))

(defun shen.read-file-as-bytelist-help (V2791 V2792 V2793) (cond ((= -1 V2792) V2793) (true (shen.read-file-as-bytelist-help V2791 (read-byte V2791) (cons V2792 V2793)))))

(defun read-file-as-string (V2794) (let Stream (open V2794 in) (shen.rfas-h Stream (read-byte Stream) "")))

(defun shen.rfas-h (V2795 V2796 V2797) (cond ((= -1 V2796) (do (close V2795) V2797)) (true (shen.rfas-h V2795 (read-byte V2795) (cn V2797 (n->string V2796))))))

(defun input (V2798) (eval-kl (read V2798)))

(defun input+ (V2799 V2800) (let Mono? (shen.monotype V2799) (let Input (read V2800) (if (= false (shen.typecheck Input (shen.rectify-type V2799))) (simple-error (cn "type error: " (shen.app Input (cn " is not of type " (shen.app V2799 "
" shen.r)) shen.r))) (eval-kl Input)))))

(defun shen.monotype (V2801) (cond ((cons? V2801) (map (lambda Z (shen.monotype Z)) V2801)) (true (if (variable? V2801) (simple-error (cn "input+ expects a monotype: not " (shen.app V2801 "
" shen.a))) V2801))))

(defun lineread (V2802) (shen.read-loop V2802 (shen.my-read-byte V2802) () (lambda X (shen.return? X))))

(defun read-from-string (V2803) (let Bytelist (shen.str->bytes V2803) (let S-exprs (compile (lambda X (shen.<s-exprs> X)) Bytelist) (let Process (shen.process-sexprs S-exprs) Process))))

(defun read-from-string-unprocessed (V2804) (let Bytelist (shen.str->bytes V2804) (let S-exprs (compile (lambda X (shen.<s-exprs> X)) Bytelist) S-exprs)))

(defun shen.str->bytes (V2805) (cond ((= "" V2805) ()) ((shen.+string? V2805) (cons (string->n (hdstr V2805)) (shen.str->bytes (tlstr V2805)))) (true (shen.f-error shen.str->bytes))))

(defun read (V2806) (hd (shen.read-loop V2806 (shen.my-read-byte V2806) () (lambda X (shen.whitespace? X)))))

(defun shen.my-read-byte (V2807) (if (shen.char-stinput? V2807) (string->n (shen.read-unit-string V2807)) (read-byte V2807)))

(defun shen.read-loop (V2812 V2813 V2814 V2815) (cond ((= 94 V2813) (simple-error "read aborted")) ((= -1 V2813) (if (empty? V2814) (simple-error "error: empty stream") (compile (lambda X (shen.<s-exprs> X)) V2814))) ((= 0 V2813) (shen.read-loop V2812 (shen.my-read-byte V2812) V2814 V2815)) (true (if (V2815 V2813) (let Parse (shen.try-parse V2814) (if (shen.nothing-doing? Parse) (shen.read-loop V2812 (shen.my-read-byte V2812) (append V2814 (cons V2813 ())) V2815) (do (shen.record-it V2814) Parse))) (shen.read-loop V2812 (shen.my-read-byte V2812) (append V2814 (cons V2813 ())) V2815)))))

(defun shen.try-parse (V2816) (let S-exprs (trap-error (compile (lambda X (shen.<s-exprs> X)) V2816) (lambda E shen.i-failed!)) (if (shen.nothing-doing? S-exprs) shen.i-failed! (shen.process-sexprs S-exprs))))

(defun shen.nothing-doing? (V2819) (cond ((= shen.i-failed! V2819) true) ((= () V2819) true) (true false)))

(defun shen.record-it (V2820) (set shen.*it* (shen.bytes->string V2820)))

(defun shen.bytes->string (V2821) (cond ((= () V2821) "") ((cons? V2821) (cn (n->string (hd V2821)) (shen.bytes->string (tl V2821)))) (true (shen.f-error shen.bytes->string))))

(defun shen.process-sexprs (V2822) (let Unpack&Expand (shen.unpackage&macroexpand V2822) (let FindArities (shen.find-arities Unpack&Expand) (let Types (shen.find-types Unpack&Expand) (map (lambda X (shen.process-applications X Types)) Unpack&Expand)))))

(defun shen.find-types (V2823) (cond ((and (cons? V2823) (and (cons? (tl V2823)) (= (hd V2823) (intern ":")))) (cons (hd (tl V2823)) (shen.find-types (tl (tl V2823))))) ((cons? V2823) (append (shen.find-types (hd V2823)) (shen.find-types (tl V2823)))) (true ())))

(defun shen.find-arities (V2826) (cond ((and (cons? V2826) (and (= define (hd V2826)) (and (cons? (tl V2826)) (and (cons? (tl (tl V2826))) (= { (hd (tl (tl V2826)))))))) (shen.store-arity (hd (tl V2826)) (shen.find-arity (hd (tl V2826)) 1 (tl (tl (tl V2826)))))) ((and (cons? V2826) (and (= define (hd V2826)) (cons? (tl V2826)))) (shen.store-arity (hd (tl V2826)) (shen.find-arity (hd (tl V2826)) 0 (tl (tl V2826))))) ((cons? V2826) (map (lambda Z (shen.find-arities Z)) V2826)) (true shen.skip)))

(defun shen.store-arity (V2827 V2828) (let ArityF (arity V2827) (if (= ArityF -1) (shen.execute-store-arity V2827 V2828) (if (= ArityF V2828) shen.skip (do (pr (cn "changing the arity of " (shen.app V2827 " may cause errors
" shen.a)) (stoutput)) (shen.execute-store-arity V2827 V2828))))))

(defun shen.execute-store-arity (V2829 V2830) (cond ((= 0 V2830) (put V2829 arity 0 (value *property-vector*))) (true (do (put V2829 arity V2830 (value *property-vector*)) (shen.update-lambdatable V2829 V2830)))))

(defun shen.update-lambdatable (V2831 V2832) (let LambdaTable (value shen.*lambdatable*) (let Lambda (eval-kl (shen.lambda-function (cons V2831 ()) V2832)) (let Insert (shen.assoc-> V2831 Lambda LambdaTable) (let Reset (set shen.*lambdatable* Insert) Reset)))))

(defun shen.lambda-function (V2835 V2836) (cond ((= 0 V2836) shen.skip) ((= 1 V2836) (let X (gensym Y) (cons lambda (cons X (cons (append V2835 (cons X ())) ()))))) (true (let X (gensym Y) (cons lambda (cons X (cons (shen.lambda-function (append V2835 (cons X ())) (- V2836 1)) ())))))))

(defun shen.assoc-> (V2846 V2847 V2848) (cond ((= () V2848) (cons (cons V2846 V2847) ())) ((and (cons? V2848) (and (cons? (hd V2848)) (= V2846 (hd (hd V2848))))) (cons (cons (hd (hd V2848)) V2847) (tl V2848))) ((cons? V2848) (cons (hd V2848) (shen.assoc-> V2846 V2847 (tl V2848)))) (true (simple-error "implementation error in shen.assoc->"))))

(defun shen.find-arity (V2863 V2864 V2865) (cond ((and (= 0 V2864) (and (cons? V2865) (= (hd V2865) ->))) 0) ((and (= 0 V2864) (and (cons? V2865) (= (hd V2865) <-))) 0) ((and (= 0 V2864) (cons? V2865)) (+ 1 (shen.find-arity V2863 0 (tl V2865)))) ((and (= 1 V2864) (and (cons? V2865) (= } (hd V2865)))) (shen.find-arity V2863 0 (tl V2865))) ((and (= 1 V2864) (cons? V2865)) (shen.find-arity V2863 1 (tl V2865))) ((= 1 V2864) (simple-error (cn "syntax error in " (shen.app V2863 " definition: missing }
" shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V2863 " definition: missing -> or <-
" shen.a))))))

(defun shen.<s-exprs> (V2866) (let Result (let Parseshen.<lsb> (shen.<lsb> V2866) (if (shen.parse-failure? Parseshen.<lsb>) (shen.parse-failure) (let Parseshen.<s-exprs1> (shen.<s-exprs1> Parseshen.<lsb>) (if (shen.parse-failure? Parseshen.<s-exprs1>) (shen.parse-failure) (let Parseshen.<rsb> (shen.<rsb> Parseshen.<s-exprs1>) (if (shen.parse-failure? Parseshen.<rsb>) (shen.parse-failure) (let Parseshen.<s-exprs2> (shen.<s-exprs2> Parseshen.<rsb>) (if (shen.parse-failure? Parseshen.<s-exprs2>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs2>) (cons (shen.cons-form (shen.<-out Parseshen.<s-exprs1>)) (shen.<-out Parseshen.<s-exprs2>))))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<lrb> (shen.<lrb> V2866) (if (shen.parse-failure? Parseshen.<lrb>) (shen.parse-failure) (let Parseshen.<s-exprs1> (shen.<s-exprs1> Parseshen.<lrb>) (if (shen.parse-failure? Parseshen.<s-exprs1>) (shen.parse-failure) (let Parseshen.<rrb> (shen.<rrb> Parseshen.<s-exprs1>) (if (shen.parse-failure? Parseshen.<rrb>) (shen.parse-failure) (let Parseshen.<s-exprs2> (shen.<s-exprs2> Parseshen.<rrb>) (if (shen.parse-failure? Parseshen.<s-exprs2>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs2>) (shen.add-sexpr (shen.<-out Parseshen.<s-exprs1>) (shen.<-out Parseshen.<s-exprs2>))))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<lcurly> (shen.<lcurly> V2866) (if (shen.parse-failure? Parseshen.<lcurly>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<lcurly>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons { (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<rcurly> (shen.<rcurly> V2866) (if (shen.parse-failure? Parseshen.<rcurly>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<rcurly>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons } (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<bar> (shen.<bar> V2866) (if (shen.parse-failure? Parseshen.<bar>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<bar>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons bar! (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<semicolon> (shen.<semicolon> V2866) (if (shen.parse-failure? Parseshen.<semicolon>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<semicolon>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ";") (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<colon> (shen.<colon> V2866) (if (shen.parse-failure? Parseshen.<colon>) (shen.parse-failure) (let Parseshen.<equal> (shen.<equal> Parseshen.<colon>) (if (shen.parse-failure? Parseshen.<equal>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<equal>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ":=") (shen.<-out Parseshen.<s-exprs>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<colon> (shen.<colon> V2866) (if (shen.parse-failure? Parseshen.<colon>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<colon>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ":") (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<comma> (shen.<comma> V2866) (if (shen.parse-failure? Parseshen.<comma>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<comma>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ",") (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<comment> (shen.<comment> V2866) (if (shen.parse-failure? Parseshen.<comment>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<comment>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<atom> (shen.<atom> V2866) (if (shen.parse-failure? Parseshen.<atom>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<atom>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (shen.<-out Parseshen.<atom>) (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<whitespaces> (shen.<whitespaces> V2866) (if (shen.parse-failure? Parseshen.<whitespaces>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<whitespaces>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V2866) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)))

(defun shen.add-sexpr (V2867 V2868) (cond ((and (cons? V2867) (and (= $ (hd V2867)) (and (cons? (tl V2867)) (= () (tl (tl V2867)))))) (append (explode (hd (tl V2867))) V2868)) (true (cons V2867 V2868))))

(defun shen.<lsb> (V2869) (let Result (if (shen.=hd? V2869 91) (let News2551 (shen.tls V2869) (shen.comb (shen.in-> News2551) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<rsb> (V2870) (let Result (if (shen.=hd? V2870 93) (let News2553 (shen.tls V2870) (shen.comb (shen.in-> News2553) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<s-exprs1> (V2871) (let Result (let Parseshen.<s-exprs> (shen.<s-exprs> V2871) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<s-exprs2> (V2872) (let Result (let Parseshen.<s-exprs> (shen.<s-exprs> V2872) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.cons-form (V2874) (cond ((= () V2874) ()) ((and (cons? V2874) (and (cons? (tl V2874)) (and (cons? (tl (tl V2874))) (and (= () (tl (tl (tl V2874)))) (= (hd (tl V2874)) bar!))))) (cons cons (cons (hd V2874) (tl (tl V2874))))) ((and (cons? V2874) (and (cons? (tl V2874)) (and (cons? (tl (tl V2874))) (and (cons? (tl (tl (tl V2874)))) (= (hd (tl V2874)) bar!))))) (simple-error "misapplication of |
")) ((cons? V2874) (cons cons (cons (hd V2874) (cons (shen.cons-form (tl V2874)) ())))) (true (shen.f-error shen.cons-form))))

(defun shen.<lrb> (V2875) (let Result (if (shen.=hd? V2875 40) (let News2557 (shen.tls V2875) (shen.comb (shen.in-> News2557) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<rrb> (V2876) (let Result (if (shen.=hd? V2876 41) (let News2559 (shen.tls V2876) (shen.comb (shen.in-> News2559) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<lcurly> (V2877) (let Result (if (shen.=hd? V2877 123) (let News2561 (shen.tls V2877) (shen.comb (shen.in-> News2561) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<rcurly> (V2878) (let Result (if (shen.=hd? V2878 125) (let News2563 (shen.tls V2878) (shen.comb (shen.in-> News2563) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<bar> (V2879) (let Result (if (shen.=hd? V2879 124) (let News2565 (shen.tls V2879) (shen.comb (shen.in-> News2565) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<semicolon> (V2880) (let Result (if (shen.=hd? V2880 59) (let News2567 (shen.tls V2880) (shen.comb (shen.in-> News2567) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<colon> (V2881) (let Result (if (shen.=hd? V2881 58) (let News2569 (shen.tls V2881) (shen.comb (shen.in-> News2569) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<comma> (V2882) (let Result (if (shen.=hd? V2882 44) (let News2571 (shen.tls V2882) (shen.comb (shen.in-> News2571) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<equal> (V2883) (let Result (if (shen.=hd? V2883 61) (let News2573 (shen.tls V2883) (shen.comb (shen.in-> News2573) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<comment> (V2884) (let Result (let Parseshen.<singleline> (shen.<singleline> V2884) (if (shen.parse-failure? Parseshen.<singleline>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<singleline>) shen.skip))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<multiline> (shen.<multiline> V2884) (if (shen.parse-failure? Parseshen.<multiline>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<multiline>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<singleline> (V2885) (let Result (let Parseshen.<backslash> (shen.<backslash> V2885) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (let Parseshen.<backslash> (shen.<backslash> Parseshen.<backslash>) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (let Parseshen.<shortnatters> (shen.<shortnatters> Parseshen.<backslash>) (if (shen.parse-failure? Parseshen.<shortnatters>) (shen.parse-failure) (let Parseshen.<returns> (shen.<returns> Parseshen.<shortnatters>) (if (shen.parse-failure? Parseshen.<returns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<returns>) shen.skip))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<backslash> (V2886) (let Result (if (shen.=hd? V2886 92) (let News2577 (shen.tls V2886) (shen.comb (shen.in-> News2577) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<shortnatters> (V2887) (let Result (let Parseshen.<shortnatter> (shen.<shortnatter> V2887) (if (shen.parse-failure? Parseshen.<shortnatter>) (shen.parse-failure) (let Parseshen.<shortnatters> (shen.<shortnatters> Parseshen.<shortnatter>) (if (shen.parse-failure? Parseshen.<shortnatters>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<shortnatters>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V2887) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<shortnatter> (V2888) (let Result (if (shen.non-empty-stream? V2888) (let Byte (shen.hds V2888) (let News2580 (shen.tls V2888) (if (not (shen.return? Byte)) (shen.comb (shen.in-> News2580) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<returns> (V2889) (let Result (let Parseshen.<return> (shen.<return> V2889) (if (shen.parse-failure? Parseshen.<return>) (shen.parse-failure) (let Parseshen.<returns> (shen.<returns> Parseshen.<return>) (if (shen.parse-failure? Parseshen.<returns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<returns>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<return> (shen.<return> V2889) (if (shen.parse-failure? Parseshen.<return>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<return>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<return> (V2890) (let Result (if (shen.non-empty-stream? V2890) (let Byte (shen.hds V2890) (let News2583 (shen.tls V2890) (if (shen.return? Byte) (shen.comb (shen.in-> News2583) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.return? (V2891) (element? V2891 (cons 9 (cons 10 (cons 13 ())))))

(defun shen.<multiline> (V2892) (let Result (let Parseshen.<backslash> (shen.<backslash> V2892) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (let Parseshen.<times> (shen.<times> Parseshen.<backslash>) (if (shen.parse-failure? Parseshen.<times>) (shen.parse-failure) (let Parseshen.<longnatter> (shen.<longnatter> Parseshen.<times>) (if (shen.parse-failure? Parseshen.<longnatter>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<longnatter>) shen.skip))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<times> (V2893) (let Result (if (shen.=hd? V2893 42) (let News2586 (shen.tls V2893) (shen.comb (shen.in-> News2586) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<longnatter> (V2894) (let Result (let Parseshen.<comment> (shen.<comment> V2894) (if (shen.parse-failure? Parseshen.<comment>) (shen.parse-failure) (let Parseshen.<longnatter> (shen.<longnatter> Parseshen.<comment>) (if (shen.parse-failure? Parseshen.<longnatter>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<longnatter>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<times> (shen.<times> V2894) (if (shen.parse-failure? Parseshen.<times>) (shen.parse-failure) (let Parseshen.<backslash> (shen.<backslash> Parseshen.<times>) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<backslash>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V2894) (let News2588 (shen.tls V2894) (let Parseshen.<longnatter> (shen.<longnatter> News2588) (if (shen.parse-failure? Parseshen.<longnatter>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<longnatter>) shen.skip)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<atom> (V2895) (let Result (let Parseshen.<str> (shen.<str> V2895) (if (shen.parse-failure? Parseshen.<str>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<str>) (shen.<-out Parseshen.<str>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<number> (shen.<number> V2895) (if (shen.parse-failure? Parseshen.<number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<number>) (shen.<-out Parseshen.<number>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<sym> (shen.<sym> V2895) (if (shen.parse-failure? Parseshen.<sym>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<sym>) (if (= (shen.<-out Parseshen.<sym>) "<>") (cons vector (cons 0 ())) (intern (shen.<-out Parseshen.<sym>)))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<sym> (V2896) (let Result (let Parseshen.<alpha> (shen.<alpha> V2896) (if (shen.parse-failure? Parseshen.<alpha>) (shen.parse-failure) (let Parseshen.<alphanums> (shen.<alphanums> Parseshen.<alpha>) (if (shen.parse-failure? Parseshen.<alphanums>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<alphanums>) (cn (shen.<-out Parseshen.<alpha>) (shen.<-out Parseshen.<alphanums>))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<alpha> (V2897) (let Result (if (shen.non-empty-stream? V2897) (let Byte (shen.hds V2897) (let News2592 (shen.tls V2897) (if (shen.alpha? Byte) (shen.comb (shen.in-> News2592) (n->string Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.alpha? (V2898) (or (shen.lowercase? V2898) (or (shen.uppercase? V2898) (shen.misc? V2898))))

(defun shen.lowercase? (V2899) (and (>= V2899 97) (<= V2899 122)))

(defun shen.uppercase? (V2900) (and (>= V2900 65) (<= V2900 90)))

(defun shen.misc? (V2901) (element? V2901 (cons 61 (cons 45 (cons 42 (cons 47 (cons 43 (cons 95 (cons 63 (cons 36 (cons 33 (cons 64 (cons 126 (cons 46 (cons 62 (cons 60 (cons 38 (cons 37 (cons 39 (cons 35 (cons 96 ())))))))))))))))))))))

(defun shen.<alphanums> (V2902) (let Result (let Parseshen.<alphanum> (shen.<alphanum> V2902) (if (shen.parse-failure? Parseshen.<alphanum>) (shen.parse-failure) (let Parseshen.<alphanums> (shen.<alphanums> Parseshen.<alphanum>) (if (shen.parse-failure? Parseshen.<alphanums>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<alphanums>) (cn (shen.<-out Parseshen.<alphanum>) (shen.<-out Parseshen.<alphanums>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V2902) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ""))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<alphanum> (V2903) (let Result (let Parseshen.<alpha> (shen.<alpha> V2903) (if (shen.parse-failure? Parseshen.<alpha>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<alpha>) (shen.<-out Parseshen.<alpha>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<numeral> (shen.<numeral> V2903) (if (shen.parse-failure? Parseshen.<numeral>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<numeral>) (shen.<-out Parseshen.<numeral>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<numeral> (V2904) (let Result (if (shen.non-empty-stream? V2904) (let Byte (shen.hds V2904) (let News2596 (shen.tls V2904) (if (shen.digit? Byte) (shen.comb (shen.in-> News2596) (n->string Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.digit? (V2905) (and (>= V2905 48) (<= V2905 57)))

(defun shen.<str> (V2906) (let Result (let Parseshen.<dbq> (shen.<dbq> V2906) (if (shen.parse-failure? Parseshen.<dbq>) (shen.parse-failure) (let Parseshen.<strcontents> (shen.<strcontents> Parseshen.<dbq>) (if (shen.parse-failure? Parseshen.<strcontents>) (shen.parse-failure) (let Parseshen.<dbq> (shen.<dbq> Parseshen.<strcontents>) (if (shen.parse-failure? Parseshen.<dbq>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<dbq>) (shen.<-out Parseshen.<strcontents>)))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<dbq> (V2907) (let Result (if (shen.=hd? V2907 34) (let News2599 (shen.tls V2907) (shen.comb (shen.in-> News2599) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<strcontents> (V2908) (let Result (let Parseshen.<strc> (shen.<strc> V2908) (if (shen.parse-failure? Parseshen.<strc>) (shen.parse-failure) (let Parseshen.<strcontents> (shen.<strcontents> Parseshen.<strc>) (if (shen.parse-failure? Parseshen.<strcontents>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<strcontents>) (cn (shen.<-out Parseshen.<strc>) (shen.<-out Parseshen.<strcontents>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V2908) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ""))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<strc> (V2909) (let Result (let Parseshen.<control> (shen.<control> V2909) (if (shen.parse-failure? Parseshen.<control>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<control>) (shen.<-out Parseshen.<control>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<notdbq> (shen.<notdbq> V2909) (if (shen.parse-failure? Parseshen.<notdbq>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<notdbq>) (shen.<-out Parseshen.<notdbq>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<control> (V2910) (let Result (let Parseshen.<lowC> (shen.<lowC> V2910) (if (shen.parse-failure? Parseshen.<lowC>) (shen.parse-failure) (let Parseshen.<hash> (shen.<hash> Parseshen.<lowC>) (if (shen.parse-failure? Parseshen.<hash>) (shen.parse-failure) (let Parseshen.<integer> (shen.<integer> Parseshen.<hash>) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (let Parseshen.<semicolon> (shen.<semicolon> Parseshen.<integer>) (if (shen.parse-failure? Parseshen.<semicolon>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<semicolon>) (n->string (shen.<-out Parseshen.<integer>))))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<notdbq> (V2911) (let Result (if (shen.non-empty-stream? V2911) (let Byte (shen.hds V2911) (let News2604 (shen.tls V2911) (if (not (= Byte 34)) (shen.comb (shen.in-> News2604) (n->string Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<lowC> (V2912) (let Result (if (shen.=hd? V2912 99) (let News2606 (shen.tls V2912) (shen.comb (shen.in-> News2606) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<hash> (V2913) (let Result (if (shen.=hd? V2913 35) (let News2608 (shen.tls V2913) (shen.comb (shen.in-> News2608) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<number> (V2914) (let Result (let Parseshen.<minus> (shen.<minus> V2914) (if (shen.parse-failure? Parseshen.<minus>) (shen.parse-failure) (let Parseshen.<number> (shen.<number> Parseshen.<minus>) (if (shen.parse-failure? Parseshen.<number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<number>) (- 0 (shen.<-out Parseshen.<number>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<plus> (shen.<plus> V2914) (if (shen.parse-failure? Parseshen.<plus>) (shen.parse-failure) (let Parseshen.<number> (shen.<number> Parseshen.<plus>) (if (shen.parse-failure? Parseshen.<number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<number>) (shen.<-out Parseshen.<number>)))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<e-number> (shen.<e-number> V2914) (if (shen.parse-failure? Parseshen.<e-number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<e-number>) (shen.<-out Parseshen.<e-number>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<float> (shen.<float> V2914) (if (shen.parse-failure? Parseshen.<float>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<float>) (shen.<-out Parseshen.<float>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<integer> (shen.<integer> V2914) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<integer>) (shen.<-out Parseshen.<integer>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)) Result)))

(defun shen.<minus> (V2915) (let Result (if (shen.=hd? V2915 45) (let News2611 (shen.tls V2915) (shen.comb (shen.in-> News2611) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<plus> (V2916) (let Result (if (shen.=hd? V2916 43) (let News2613 (shen.tls V2916) (shen.comb (shen.in-> News2613) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<integer> (V2917) (let Result (let Parseshen.<digits> (shen.<digits> V2917) (if (shen.parse-failure? Parseshen.<digits>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digits>) (shen.compute-integer (shen.<-out Parseshen.<digits>))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<digits> (V2918) (let Result (let Parseshen.<digit> (shen.<digit> V2918) (if (shen.parse-failure? Parseshen.<digit>) (shen.parse-failure) (let Parseshen.<digits> (shen.<digits> Parseshen.<digit>) (if (shen.parse-failure? Parseshen.<digits>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digits>) (cons (shen.<-out Parseshen.<digit>) (shen.<-out Parseshen.<digits>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<digit> (shen.<digit> V2918) (if (shen.parse-failure? Parseshen.<digit>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digit>) (cons (shen.<-out Parseshen.<digit>) ())))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<digit> (V2919) (let Result (if (shen.non-empty-stream? V2919) (let Byte (shen.hds V2919) (let News2617 (shen.tls V2919) (if (shen.digit? Byte) (shen.comb (shen.in-> News2617) (shen.byte->digit Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.byte->digit (V2920) (- V2920 48))

(defun shen.compute-integer (V2921) (shen.compute-integer-h (reverse V2921) 0))

(defun shen.compute-integer-h (V2924 V2925) (cond ((= () V2924) 0) ((cons? V2924) (+ (* (shen.expt 10 V2925) (hd V2924)) (shen.compute-integer-h (tl V2924) (+ V2925 1)))) (true (shen.f-error shen.compute-integer-h))))

(defun shen.expt (V2928 V2929) (cond ((= 0 V2929) 1) ((> V2929 0) (* V2928 (shen.expt V2928 (- V2929 1)))) (true (/ (shen.expt V2928 (+ V2929 1)) V2928))))

(defun shen.<float> (V2930) (let Result (let Parseshen.<integer> (shen.<integer> V2930) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (let Parseshen.<stop> (shen.<stop> Parseshen.<integer>) (if (shen.parse-failure? Parseshen.<stop>) (shen.parse-failure) (let Parseshen.<fraction> (shen.<fraction> Parseshen.<stop>) (if (shen.parse-failure? Parseshen.<fraction>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<fraction>) (+ (shen.<-out Parseshen.<integer>) (shen.<-out Parseshen.<fraction>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<stop> (shen.<stop> V2930) (if (shen.parse-failure? Parseshen.<stop>) (shen.parse-failure) (let Parseshen.<fraction> (shen.<fraction> Parseshen.<stop>) (if (shen.parse-failure? Parseshen.<fraction>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<fraction>) (shen.<-out Parseshen.<fraction>)))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<stop> (V2931) (let Result (if (shen.=hd? V2931 46) (let News2620 (shen.tls V2931) (shen.comb (shen.in-> News2620) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<fraction> (V2932) (let Result (let Parseshen.<digits> (shen.<digits> V2932) (if (shen.parse-failure? Parseshen.<digits>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digits>) (shen.compute-fraction (shen.<-out Parseshen.<digits>))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.compute-fraction (V2933) (shen.compute-fraction-h V2933 -1))

(defun shen.compute-fraction-h (V2936 V2937) (cond ((= () V2936) 0) ((cons? V2936) (+ (* (shen.expt 10 V2937) (hd V2936)) (shen.compute-fraction-h (tl V2936) (- V2937 1)))) (true (shen.f-error shen.compute-fraction-h))))

(defun shen.<e-number> (V2938) (let Result (let Parseshen.<float> (shen.<float> V2938) (if (shen.parse-failure? Parseshen.<float>) (shen.parse-failure) (let Parseshen.<lowE> (shen.<lowE> Parseshen.<float>) (if (shen.parse-failure? Parseshen.<lowE>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<lowE>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (shen.compute-E (shen.<-out Parseshen.<float>) (shen.<-out Parseshen.<log10>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<integer> (shen.<integer> V2938) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (let Parseshen.<lowE> (shen.<lowE> Parseshen.<integer>) (if (shen.parse-failure? Parseshen.<lowE>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<lowE>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (shen.compute-E (shen.<-out Parseshen.<integer>) (shen.<-out Parseshen.<log10>))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<log10> (V2939) (let Result (let Parseshen.<plus> (shen.<plus> V2939) (if (shen.parse-failure? Parseshen.<plus>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<plus>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (shen.<-out Parseshen.<log10>)))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<minus> (shen.<minus> V2939) (if (shen.parse-failure? Parseshen.<minus>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<minus>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (- 0 (shen.<-out Parseshen.<log10>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<integer> (shen.<integer> V2939) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<integer>) (shen.<-out Parseshen.<integer>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<lowE> (V2940) (let Result (if (shen.=hd? V2940 101) (let News2625 (shen.tls V2940) (shen.comb (shen.in-> News2625) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.compute-E (V2941 V2942) (* V2941 (shen.expt 10 V2942)))

(defun shen.<whitespaces> (V2943) (let Result (let Parseshen.<whitespace> (shen.<whitespace> V2943) (if (shen.parse-failure? Parseshen.<whitespace>) (shen.parse-failure) (let Parseshen.<whitespaces> (shen.<whitespaces> Parseshen.<whitespace>) (if (shen.parse-failure? Parseshen.<whitespaces>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<whitespaces>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<whitespace> (shen.<whitespace> V2943) (if (shen.parse-failure? Parseshen.<whitespace>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<whitespace>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<whitespace> (V2944) (let Result (if (shen.non-empty-stream? V2944) (let Byte (shen.hds V2944) (let News2628 (shen.tls V2944) (if (shen.whitespace? Byte) (shen.comb (shen.in-> News2628) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.whitespace? (V2947) (cond ((= 32 V2947) true) ((= 13 V2947) true) ((= 10 V2947) true) ((= 9 V2947) true) (true false)))

(defun shen.unpackage&macroexpand (V2948) (cond ((= () V2948) ()) ((and (cons? V2948) (shen.packaged? (hd V2948))) (shen.unpackage&macroexpand (append (shen.unpackage (hd V2948)) (tl V2948)))) ((cons? V2948) (let M (macroexpand (hd V2948)) (if (shen.packaged? M) (shen.unpackage&macroexpand (cons M (tl V2948))) (cons M (shen.unpackage&macroexpand (tl V2948)))))) (true (shen.f-error shen.unpackage&macroexpand))))

(defun shen.packaged? (V2951) (cond ((and (cons? V2951) (and (= package (hd V2951)) (and (cons? (tl V2951)) (cons? (tl (tl V2951)))))) true) (true false)))

(defun shen.unpackage (V2954) (cond ((and (cons? V2954) (and (= package (hd V2954)) (and (cons? (tl V2954)) (and (= null (hd (tl V2954))) (cons? (tl (tl V2954))))))) (tl (tl (tl V2954)))) ((and (cons? V2954) (and (= package (hd V2954)) (and (cons? (tl V2954)) (cons? (tl (tl V2954)))))) (let External! (eval (hd (tl (tl V2954)))) (let Package (shen.package-symbols (str (hd (tl V2954))) External! (tl (tl (tl V2954)))) (let RecordExternal (shen.record-external (hd (tl V2954)) External!) Package)))) (true (shen.f-error shen.unpackage))))

(defun shen.record-external (V2955 V2956) (let External (trap-error (get V2955 shen.external-symbols (value *property-vector*)) (lambda E ())) (put V2955 shen.external-symbols (union V2956 External) (value *property-vector*))))

(defun shen.package-symbols (V2961 V2962 V2963) (cond ((cons? V2963) (map (lambda X (shen.package-symbols V2961 V2962 X)) V2963)) ((shen.internal? V2963 V2961 V2962) (shen.intern-in-package V2961 V2963)) (true V2963)))

(defun shen.intern-in-package (V2964 V2965) (intern (@s V2964 (@s "." (str V2965)))))

(defun shen.internal? (V2966 V2967 V2968) (and (not (element? V2966 V2968)) (and (not (shen.sng? V2966)) (and (not (shen.dbl? V2966)) (and (symbol? V2966) (and (not (shen.sysfunc? V2966)) (and (not (variable? V2966)) (and (not (shen.internal-to-shen? (str V2966))) (not (shen.internal-to-P? V2967 (str V2966)))))))))))

(defun shen.internal-to-shen? (V2973) (cond ((and (shen.+string? V2973) (and (= "s" (hdstr V2973)) (and (shen.+string? (tlstr V2973)) (and (= "h" (hdstr (tlstr V2973))) (and (shen.+string? (tlstr (tlstr V2973))) (and (= "e" (hdstr (tlstr (tlstr V2973)))) (and (shen.+string? (tlstr (tlstr (tlstr V2973)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V2973))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V2973))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V2973))))))))))))))) true) (true false)))

(defun shen.sysfunc? (V2974) (element? V2974 (get shen shen.external-symbols (value *property-vector*))))

(defun shen.internal-to-P? (V2982 V2983) (cond ((and (= "" V2982) (and (shen.+string? V2983) (= "." (hdstr V2983)))) true) ((and (shen.+string? V2982) (and (shen.+string? V2983) (= (hdstr V2982) (hdstr V2983)))) (shen.internal-to-P? (tlstr V2982) (tlstr V2983))) (true false)))

(defun shen.process-applications (V2986 V2987) (cond ((element? V2986 V2987) V2986) ((and (cons? V2986) (shen.non-application? (hd V2986))) (shen.special-case (hd V2986) V2986 V2987)) ((cons? V2986) (shen.process-application (map (lambda Y (shen.process-applications Y V2987)) V2986) V2987)) (true V2986)))

(defun shen.non-application? (V2990) (cond ((= define V2990) true) ((= defun V2990) true) ((= synonyms V2990) true) ((shen.special? V2990) true) ((shen.extraspecial? V2990) true) (true false)))

(defun shen.special-case (V2995 V2996 V2997) (cond ((and (= lambda V2995) (and (cons? V2996) (and (= lambda (hd V2996)) (and (cons? (tl V2996)) (and (cons? (tl (tl V2996))) (= () (tl (tl (tl V2996))))))))) (cons lambda (cons (hd (tl V2996)) (cons (shen.process-applications (hd (tl (tl V2996))) V2997) ())))) ((and (= let V2995) (and (cons? V2996) (and (= let (hd V2996)) (and (cons? (tl V2996)) (and (cons? (tl (tl V2996))) (and (cons? (tl (tl (tl V2996)))) (= () (tl (tl (tl (tl V2996))))))))))) (cons let (cons (hd (tl V2996)) (cons (shen.process-applications (hd (tl (tl V2996))) V2997) (cons (shen.process-applications (hd (tl (tl (tl V2996)))) V2997) ()))))) ((and (= defun V2995) (and (cons? V2996) (and (= defun (hd V2996)) (and (cons? (tl V2996)) (and (cons? (tl (tl V2996))) (and (cons? (tl (tl (tl V2996)))) (= () (tl (tl (tl (tl V2996))))))))))) V2996) ((and (= define V2995) (and (cons? V2996) (and (= define (hd V2996)) (and (cons? (tl V2996)) (and (cons? (tl (tl V2996))) (= { (hd (tl (tl V2996))))))))) (cons define (cons (hd (tl V2996)) (cons { (shen.process-after-type (hd (tl V2996)) (tl (tl (tl V2996))) V2997))))) ((and (= define V2995) (and (cons? V2996) (and (= define (hd V2996)) (cons? (tl V2996))))) (cons define (cons (hd (tl V2996)) (map (lambda Y (shen.process-applications Y V2997)) (tl (tl V2996)))))) ((= synonyms V2995) (cons synonyms V2996)) ((and (= type V2995) (and (cons? V2996) (and (= type (hd V2996)) (and (cons? (tl V2996)) (and (cons? (tl (tl V2996))) (= () (tl (tl (tl V2996))))))))) (cons type (cons (shen.process-applications (hd (tl V2996)) V2997) (tl (tl V2996))))) ((and (= input+ V2995) (and (cons? V2996) (and (= input+ (hd V2996)) (and (cons? (tl V2996)) (and (cons? (tl (tl V2996))) (= () (tl (tl (tl V2996))))))))) (cons input+ (cons (hd (tl V2996)) (cons (shen.process-applications (hd (tl (tl V2996))) V2997) ())))) ((and (cons? V2996) (shen.special? (hd V2996))) (cons (hd V2996) (map (lambda Y (shen.process-applications Y V2997)) (tl V2996)))) ((and (cons? V2996) (shen.extraspecial? (hd V2996))) V2996) (true (shen.f-error shen.special-case))))

(defun shen.process-after-type (V3000 V3001 V3002) (cond ((and (cons? V3001) (= } (hd V3001))) (cons } (map (lambda Y (shen.process-applications Y V3002)) (tl V3001)))) ((cons? V3001) (cons (hd V3001) (shen.process-after-type V3000 (tl V3001) V3002))) (true (simple-error (cn "missing } in " (shen.app V3000 "
" shen.a))))))

(defun shen.process-application (V3003 V3004) (cond ((cons? V3003) (let ArityF (arity (hd V3003)) (let N (length (tl V3003)) (if (element? V3003 V3004) V3003 (if (shen.shen-call? (hd V3003)) V3003 (if (shen.fn-call? V3003) (shen.fn-call V3003) (if (shen.zero-place? V3003) V3003 (if (shen.undefined-f? (hd V3003) ArityF) (shen.simple-curry (cons (cons fn (cons (hd V3003) ())) (tl V3003))) (if (variable? (hd V3003)) (shen.simple-curry V3003) (if (shen.application? (hd V3003)) (shen.simple-curry V3003) (if (shen.partial-application*? (hd V3003) ArityF N) (shen.lambda-function V3003 (- ArityF N)) (if (shen.overapplication? (hd V3003) ArityF N) (shen.simple-curry V3003) V3003)))))))))))) (true (shen.f-error shen.process-application))))

(defun shen.zero-place? (V3007) (cond ((and (cons? V3007) (= () (tl V3007))) true) (true false)))

(defun shen.shen-call? (V3008) (and (symbol? V3008) (shen.internal-to-shen? (str V3008))))

(defun shen.internal-to-shen? (V3013) (cond ((and (shen.+string? V3013) (and (= "s" (hdstr V3013)) (and (shen.+string? (tlstr V3013)) (and (= "h" (hdstr (tlstr V3013))) (and (shen.+string? (tlstr (tlstr V3013))) (and (= "e" (hdstr (tlstr (tlstr V3013)))) (and (shen.+string? (tlstr (tlstr (tlstr V3013)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V3013))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V3013))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V3013))))))))))))))) true) (true false)))

(defun shen.application? (V3016) (cond ((and (cons? V3016) (and (= protect (hd V3016)) (and (cons? (tl V3016)) (= () (tl (tl V3016)))))) false) (true (cons? V3016))))

(defun shen.undefined-f? (V3021 V3022) (cond ((= -1 V3022) (and (shen.lowercase-symbol? V3021) (not (element? V3021 (external shen))))) (true false)))

(defun shen.lowercase-symbol? (V3023) (and (symbol? V3023) (not (variable? V3023))))

(defun shen.simple-curry (V3024) (cond ((and (cons? V3024) (and (cons? (tl V3024)) (= () (tl (tl V3024))))) V3024) ((and (cons? V3024) (and (cons? (tl V3024)) (cons? (tl (tl V3024))))) (shen.simple-curry (cons (cons (hd V3024) (cons (hd (tl V3024)) ())) (tl (tl V3024))))) (true V3024)))

(defun function (V3025) (fn V3025))

(defun fn (V3026) (let LookUp (assoc V3026 (value shen.*lambdatable*)) (if (empty? LookUp) (simple-error (cn "fn: " (shen.app V3026 " is undefined
" shen.a))) (tl LookUp))))

(defun shen.fn-call? (V3029) (cond ((and (cons? V3029) (and (= fn (hd V3029)) (and (cons? (tl V3029)) (= () (tl (tl V3029)))))) true) ((and (cons? V3029) (and (= function (hd V3029)) (and (cons? (tl V3029)) (= () (tl (tl V3029)))))) true) (true false)))

(defun shen.fn-call (V3030) (cond ((and (cons? V3030) (and (= function (hd V3030)) (and (cons? (tl V3030)) (= () (tl (tl V3030)))))) (shen.fn-call (cons fn (tl V3030)))) ((and (cons? V3030) (and (= fn (hd V3030)) (and (cons? (tl V3030)) (= () (tl (tl V3030)))))) (let ArityF (arity (hd (tl V3030))) (if (= ArityF -1) V3030 (if (= ArityF 0) (simple-error "fn cannot be applied to a zero place function
") (shen.lambda-function (tl V3030) ArityF))))) (true (shen.f-error shen.fn-call))))

(defun shen.partial-application*? (V3031 V3032 V3033) (let Verdict (> V3032 V3033) (let Message (if (and Verdict (and (shen.loading?) (not (element? V3031 (cons + (cons - ())))))) (pr (cn "partial application of " (shen.app V3031 "
" shen.a)) (stoutput)) shen.skip) Verdict)))

(defun shen.loading? () (value shen.*loading?*))

(defun shen.overapplication? (V3038 V3039 V3040) (cond ((= -1 V3039) false) (true (let Verdict (< V3039 V3040) (let Message (if (and Verdict (shen.loading?)) (pr (shen.app V3038 (cn " might not like " (shen.app V3040 (cn " argument" (shen.app (if (= V3040 1) "" "s") "
" shen.a)) shen.a)) shen.a) (stoutput)) shen.skip) Verdict)))))

