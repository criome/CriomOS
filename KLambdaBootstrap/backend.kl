(defun cl.kl-to-lisp (V4889) (cl.kl-to-lisp-h () V4889))

(defun cl.kl-to-lisp-h (V4897 V4898) (cond ((= T (MEMBER V4898 V4897)) V4898) ((and (cons? V4898) (and (= type (hd V4898)) (and (cons? (tl V4898)) (and (cons? (tl (tl V4898))) (= () (tl (tl (tl V4898)))))))) (cl.kl-to-lisp-h V4897 (hd (tl V4898)))) ((and (cons? V4898) (and (= protect (hd V4898)) (and (cons? (tl V4898)) (= () (tl (tl V4898)))))) (cl.kl-to-lisp-h V4897 (hd (tl V4898)))) ((and (cons? V4898) (and (= lambda (hd V4898)) (and (cons? (tl V4898)) (and (cons? (tl (tl V4898))) (and (= () (tl (tl (tl V4898)))) (= (hd (tl V4898)) T)))))) (cl.kl-to-lisp-h V4897 (cl.rectify-t V4898))) ((and (cons? V4898) (and (= lambda (hd V4898)) (and (cons? (tl V4898)) (and (cons? (tl (tl V4898))) (= () (tl (tl (tl V4898)))))))) (cons FUNCTION (cons (cons LAMBDA (cons (cons (hd (tl V4898)) ()) (cons (cl.kl-to-lisp-h (cons (hd (tl V4898)) V4897) (hd (tl (tl V4898)))) ()))) ()))) ((and (cons? V4898) (and (= let (hd V4898)) (and (cons? (tl V4898)) (and (cons? (tl (tl V4898))) (and (cons? (tl (tl (tl V4898)))) (and (= () (tl (tl (tl (tl V4898))))) (= (hd (tl V4898)) T))))))) (cl.kl-to-lisp-h V4897 (cl.rectify-t V4898))) ((and (cons? V4898) (and (= let (hd V4898)) (and (cons? (tl V4898)) (and (cons? (tl (tl V4898))) (and (cons? (tl (tl (tl V4898)))) (= () (tl (tl (tl (tl V4898)))))))))) (cons LET (cons (cons (cons (hd (tl V4898)) (cons (cl.kl-to-lisp-h V4897 (hd (tl (tl V4898)))) ())) ()) (cons (cl.kl-to-lisp-h (cons (hd (tl V4898)) V4897) (hd (tl (tl (tl V4898))))) ())))) ((and (cons? V4898) (and (= defun (hd V4898)) (and (cons? (tl V4898)) (and (cons? (tl (tl V4898))) (and (cons? (tl (tl (tl V4898)))) (= () (tl (tl (tl (tl V4898)))))))))) (cons DEFUN (cons (hd (tl V4898)) (cons (hd (tl (tl V4898))) (cons (cl.kl-to-lisp-h (hd (tl (tl V4898))) (hd (tl (tl (tl V4898))))) ()))))) ((and (cons? V4898) (= cond (hd V4898))) (cons COND (CL.MAPCAR (lambda C (cl.cond-code V4897 C)) (tl V4898)))) ((and (cons? V4898) (or (= T (MEMBER (hd V4898) V4897)) (cons? (hd V4898)))) (let Lisp (CL.MAPCAR (lambda Y (cl.kl-to-lisp-h V4897 Y)) V4898) (cl.currylisp Lisp))) ((and (cons? V4898) (cl.fastsymbol? (hd V4898))) (let LispX (CL.MAPCAR (lambda Y (cl.kl-to-lisp-h V4897 Y)) (tl V4898)) (let LispF (cl.maplispsym (hd V4898)) (cl.optimise-application (cons LispF LispX))))) ((or (number? V4898) (or (string? V4898) (empty? V4898))) V4898) (true (cons QUOTE (cons V4898 ())))))

(defun cl.rectify-t (V4899) (SUBST (GENSYM "x") T V4899))

(defun cl.currylisp (V4900) (cond ((and (cons? V4900) (and (cons? (tl V4900)) (cons? (tl (tl V4900))))) (cl.currylisp (cons (cons FUNCALL (cons (hd V4900) (cons (hd (tl V4900)) ()))) (tl (tl V4900))))) ((and (cons? V4900) (and (cons? (tl V4900)) (= () (tl (tl V4900))))) (cons FUNCALL V4900)) ((and (cons? V4900) (= () (tl V4900))) (cons FUNCALL V4900)) (true V4900)))

(defun cl.optimise-application (V4901) (cond ((and (cons? V4901) (and (= protect (hd V4901)) (and (cons? (tl V4901)) (= () (tl (tl V4901)))))) (cl.optimise-application (hd (tl V4901)))) ((and (cons? V4901) (and (= hd (hd V4901)) (and (cons? (tl V4901)) (= () (tl (tl V4901)))))) (cons CAR (cons (cl.optimise-application (hd (tl V4901))) ()))) ((and (cons? V4901) (and (= tl (hd V4901)) (and (cons? (tl V4901)) (= () (tl (tl V4901)))))) (cons CDR (cons (cl.optimise-application (hd (tl V4901))) ()))) ((and (cons? V4901) (and (= cons (hd V4901)) (and (cons? (tl V4901)) (and (cons? (tl (tl V4901))) (= () (tl (tl (tl V4901)))))))) (cons CONS (cons (cl.optimise-application (hd (tl V4901))) (cons (cl.optimise-application (hd (tl (tl V4901)))) ())))) ((and (cons? V4901) (and (= append (hd V4901)) (and (cons? (tl V4901)) (and (cons? (tl (tl V4901))) (= () (tl (tl (tl V4901)))))))) (cons APPEND (cons (cl.optimise-application (hd (tl V4901))) (cons (cl.optimise-application (hd (tl (tl V4901)))) ())))) ((and (cons? V4901) (and (= reverse (hd V4901)) (and (cons? (tl V4901)) (= () (tl (tl V4901)))))) (cons REVERSE (cons (cl.optimise-application (hd (tl V4901))) ()))) ((and (cons? V4901) (and (= length (hd V4901)) (and (cons? (tl V4901)) (= () (tl (tl V4901)))))) (cons CL.LIST-LENGTH (cons (cl.optimise-application (hd (tl V4901))) ()))) ((and (cons? V4901) (and (= if (hd V4901)) (and (cons? (tl V4901)) (and (cons? (tl (tl V4901))) (and (cons? (tl (tl (tl V4901)))) (= () (tl (tl (tl (tl V4901)))))))))) (cons IF (cons (cl.wrap (hd (tl V4901))) (cons (cl.optimise-application (hd (tl (tl V4901)))) (cons (cl.optimise-application (hd (tl (tl (tl V4901))))) ()))))) ((and (cons? V4901) (and (= value (hd V4901)) (and (cons? (tl V4901)) (and (cons? (hd (tl V4901))) (and (cons? (tl (hd (tl V4901)))) (and (= () (tl (tl (hd (tl V4901))))) (and (= () (tl (tl V4901))) (= (hd (hd (tl V4901))) QUOTE)))))))) (hd (tl (hd (tl V4901))))) ((and (cons? V4901) (and (= map (hd V4901)) (and (cons? (tl V4901)) (and (cons? (tl (tl V4901))) (= () (tl (tl (tl V4901)))))))) (cons CL.MAPCAR (tl V4901))) ((and (cons? V4901) (and (= + (hd V4901)) (and (cons? (tl V4901)) (and (= 1 (hd (tl V4901))) (and (cons? (tl (tl V4901))) (= () (tl (tl (tl V4901))))))))) (cons (intern "1+") (cons (cl.optimise-application (hd (tl (tl V4901)))) ()))) ((and (cons? V4901) (and (= + (hd V4901)) (and (cons? (tl V4901)) (and (cons? (tl (tl V4901))) (and (= 1 (hd (tl (tl V4901)))) (= () (tl (tl (tl V4901))))))))) (cons (intern "1+") (cons (cl.optimise-application (hd (tl V4901))) ()))) ((and (cons? V4901) (and (= - (hd V4901)) (and (cons? (tl V4901)) (and (cons? (tl (tl V4901))) (and (= 1 (hd (tl (tl V4901)))) (= () (tl (tl (tl V4901))))))))) (cons (intern "1-") (cons (cl.optimise-application (hd (tl V4901))) ()))) ((cons? V4901) (CL.MAPCAR (lambda Z (cl.optimise-application Z)) V4901)) (true V4901)))

(defun cl.cond-code (V4906 V4907) (cond ((and (cons? V4907) (and (cons? (tl V4907)) (= () (tl (tl V4907))))) (let LispTest (cl.wrap (cl.kl-to-lisp-h V4906 (hd V4907))) (let LispResult (cl.kl-to-lisp-h V4906 (hd (tl V4907))) (cons LispTest (cons LispResult ()))))) (true (simple-error "implementation error in shen.cond-code"))))

(defun cl.wrap (V4908) (cond ((and (cons? V4908) (and (cons? (tl V4908)) (and (= true (hd (tl V4908))) (and (= () (tl (tl V4908))) (= (hd V4908) QUOTE))))) T) ((and (cons? V4908) (and (= cons? (hd V4908)) (and (cons? (tl V4908)) (= () (tl (tl V4908)))))) (cons CONSP (tl V4908))) ((and (cons? V4908) (and (= string? (hd V4908)) (and (cons? (tl V4908)) (= () (tl (tl V4908)))))) (cons STRINGP (tl V4908))) ((and (cons? V4908) (and (= number? (hd V4908)) (and (cons? (tl V4908)) (= () (tl (tl V4908)))))) (cons NUMBERP (tl V4908))) ((and (cons? V4908) (and (= empty? (hd V4908)) (and (cons? (tl V4908)) (= () (tl (tl V4908)))))) (cons NULL (tl V4908))) ((and (cons? V4908) (and (= and (hd V4908)) (and (cons? (tl V4908)) (and (cons? (tl (tl V4908))) (= () (tl (tl (tl V4908)))))))) (cons AND (cons (cl.wrap (hd (tl V4908))) (cons (cl.wrap (hd (tl (tl V4908)))) ())))) ((and (cons? V4908) (and (= or (hd V4908)) (and (cons? (tl V4908)) (and (cons? (tl (tl V4908))) (= () (tl (tl (tl V4908)))))))) (cons OR (cons (cl.wrap (hd (tl V4908))) (cons (cl.wrap (hd (tl (tl V4908)))) ())))) ((and (cons? V4908) (and (= not (hd V4908)) (and (cons? (tl V4908)) (= () (tl (tl V4908)))))) (cons NOT (cons (cl.wrap (hd (tl V4908))) ()))) ((and (cons? V4908) (and (= cl.equal? (hd V4908)) (and (cons? (tl V4908)) (and (cons? (tl (tl V4908))) (and (= () (hd (tl (tl V4908)))) (= () (tl (tl (tl V4908))))))))) (cons NULL (cons (hd (tl V4908)) ()))) ((and (cons? V4908) (and (= cl.equal? (hd V4908)) (and (cons? (tl V4908)) (and (= () (hd (tl V4908))) (and (cons? (tl (tl V4908))) (= () (tl (tl (tl V4908))))))))) (cons NULL (tl (tl V4908)))) ((and (cons? V4908) (and (= cl.equal? (hd V4908)) (and (cons? (tl V4908)) (and (cons? (tl (tl V4908))) (and (cons? (hd (tl (tl V4908)))) (and (cons? (tl (hd (tl (tl V4908))))) (and (= () (tl (tl (hd (tl (tl V4908)))))) (and (= () (tl (tl (tl V4908)))) (and (= (hd (hd (tl (tl V4908)))) QUOTE) (cl.fastsymbol? (hd (tl (hd (tl (tl V4908))))))))))))))) (cons EQ (tl V4908))) ((and (cons? V4908) (and (= cl.equal? (hd V4908)) (and (cons? (tl V4908)) (and (cons? (hd (tl V4908))) (and (cons? (tl (hd (tl V4908)))) (and (= () (tl (tl (hd (tl V4908))))) (and (cons? (tl (tl V4908))) (and (= () (tl (tl (tl V4908)))) (and (= (hd (hd (tl V4908))) QUOTE) (cl.fastsymbol? (hd (tl (hd (tl V4908)))))))))))))) (cons EQ (tl V4908))) ((and (cons? V4908) (and (= cl.equal? (hd V4908)) (and (cons? (tl V4908)) (and (cons? (hd (tl V4908))) (and (= fail (hd (hd (tl V4908)))) (and (= () (tl (hd (tl V4908)))) (and (cons? (tl (tl V4908))) (= () (tl (tl (tl V4908))))))))))) (cons EQ (tl V4908))) ((and (cons? V4908) (and (= cl.equal? (hd V4908)) (and (cons? (tl V4908)) (and (cons? (tl (tl V4908))) (and (cons? (hd (tl (tl V4908)))) (and (= fail (hd (hd (tl (tl V4908))))) (and (= () (tl (hd (tl (tl V4908))))) (= () (tl (tl (tl V4908))))))))))) (cons EQ (tl V4908))) ((and (cons? V4908) (and (= cl.equal? (hd V4908)) (and (cons? (tl V4908)) (and (cons? (tl (tl V4908))) (and (= () (tl (tl (tl V4908)))) (string? (hd (tl V4908)))))))) (cons EQUAL (tl V4908))) ((and (cons? V4908) (and (= cl.equal? (hd V4908)) (and (cons? (tl V4908)) (and (cons? (tl (tl V4908))) (and (= () (tl (tl (tl V4908)))) (string? (hd (tl (tl V4908))))))))) (cons EQUAL (tl V4908))) ((and (cons? V4908) (and (= cl.equal? (hd V4908)) (and (cons? (tl V4908)) (and (cons? (tl (tl V4908))) (and (= () (tl (tl (tl V4908)))) (number? (hd (tl V4908)))))))) (cons EQL (tl V4908))) ((and (cons? V4908) (and (= cl.equal? (hd V4908)) (and (cons? (tl V4908)) (and (cons? (tl (tl V4908))) (and (= () (tl (tl (tl V4908)))) (number? (hd (tl (tl V4908))))))))) (cons EQL (tl V4908))) ((and (cons? V4908) (and (= cl.equal? (hd V4908)) (and (cons? (tl V4908)) (and (cons? (tl (tl V4908))) (= () (tl (tl (tl V4908)))))))) (cons shen.ABSEQUAL (tl V4908))) ((and (cons? V4908) (and (= cl.greater? (hd V4908)) (and (cons? (tl V4908)) (and (cons? (tl (tl V4908))) (= () (tl (tl (tl V4908)))))))) (cons > (tl V4908))) ((and (cons? V4908) (and (= cl.greater-than-or-equal-to? (hd V4908)) (and (cons? (tl V4908)) (and (cons? (tl (tl V4908))) (= () (tl (tl (tl V4908)))))))) (cons >= (tl V4908))) ((and (cons? V4908) (and (= cl.less? (hd V4908)) (and (cons? (tl V4908)) (and (cons? (tl (tl V4908))) (= () (tl (tl (tl V4908)))))))) (cons < (tl V4908))) ((and (cons? V4908) (and (= cl.less-than-or-equal-to? (hd V4908)) (and (cons? (tl V4908)) (and (cons? (tl (tl V4908))) (= () (tl (tl (tl V4908)))))))) (cons <= (tl V4908))) (true (cons cl.wrapper (cons V4908 ())))))

(defun cl.fastsymbol? (V4915) (cond ((cons? V4915) false) ((= () V4915) false) ((string? V4915) false) ((number? V4915) false) (true true)))

(defun cl.wrapper (V4916) (cond ((= true V4916) T) ((= false V4916) ()) (true (simple-error "boolean expected"))))

(defun cl.maplispsym (V4917) (cond ((= = V4917) cl.equal?) ((= > V4917) cl.greater?) ((= < V4917) cl.less?) ((= >= V4917) cl.greater-than-or-equal-to?) ((= <= V4917) cl.less-than-or-equal-to?) ((= + V4917) cl.add) ((= - V4917) cl.subtract) ((= / V4917) cl.divide) ((= * V4917) cl.multiply) (true V4917)))

