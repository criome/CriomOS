(defun shen.typecheck (V4320 V4321) (let Vs (shen.extract-vars V4321) (let A* (shen.rectify-type V4321) (let Curried (shen.curry V4320) (((((lambda V3722 (lambda L3723 (lambda K3724 (lambda C3725 (let Out (shen.newpv V3722) (shen.gc V3722 (do (shen.incinfs) (shen.insert-prolog-variables (receive (shen.deref Vs V3722)) (receive (shen.deref A* V3722)) Out V3722 L3723 K3724 (freeze (shen.toplevel-forms (receive (shen.deref Curried V3722)) Out V3722 L3723 K3724 (freeze (return Out V3722 L3723 K3724 C3725)))))))))))) (shen.reset-prolog-vector)) (@v true (@v 0 (vector 0)))) 0) (freeze true))))))

(defun shen.insert-prolog-variables (V4322 V4323 V4324 V4325 V4326 V4327 V4328) (let C3734 (if (shen.unlocked? V4326) (let Tm3735 (shen.lazyderef V4322 V4325) (if (= Tm3735 ()) (do (shen.incinfs) (is! V4323 V4324 V4325 V4326 V4327 V4328)) false)) false) (if (= C3734 false) (if (shen.unlocked? V4326) (let Tm3736 (shen.lazyderef V4322 V4325) (if (cons? Tm3736) (let V (hd Tm3736) (let Vs (tl Tm3736) (let X (shen.newpv V4325) (shen.gc V4325 (do (shen.incinfs) (shen.insert-prolog-variables Vs (subst (shen.deref X V4325) V V4323) V4324 V4325 V4326 V4327 V4328)))))) false)) false) C3734)))

(defun shen.toplevel-forms (V4329 V4330 V4331 V4332 V4333 V4334) (let K3739 (+ V4333 1) (let C3743 (if (shen.unlocked? V4332) (let Tm3744 (shen.lazyderef V4329 V4331) (if (cons? Tm3744) (let Tm3745 (shen.lazyderef (hd Tm3744) V4331) (if (= Tm3745 define) (let Tm3746 (shen.lazyderef (tl Tm3744) V4331) (if (cons? Tm3746) (let F (hd Tm3746) (let X (tl Tm3746) (do (shen.incinfs) (shen.cut V4331 V4332 K3739 (freeze (shen.signal-def (value shen.*spy*) F V4331 V4332 K3739 (freeze (shen.t* (cons define (cons F X)) V4330 V4331 V4332 K3739 V4334)))))))) false)) false)) false)) false) (if (= C3743 false) (let C3747 (if (shen.unlocked? V4332) (do (shen.incinfs) (shen.system-S (cons V4329 (cons (intern ":") (cons V4330 ()))) () V4331 V4332 K3739 V4334)) false) (if (= C3747 false) (shen.unlock V4332 K3739) C3747)) C3743))))

(defun shen.signal-def (V4335 V4336 V4337 V4338 V4339 V4340) (let C3754 (if (shen.unlocked? V4338) (let Tm3755 (shen.lazyderef V4335 V4337) (if (= Tm3755 false) (do (shen.incinfs) (thaw V4340)) false)) false) (if (= C3754 false) (if (shen.unlocked? V4338) (let Tm3756 (shen.lazyderef V4335 V4337) (if (= Tm3756 true) (let ShowF (shen.newpv V4337) (shen.gc V4337 (do (shen.incinfs) (is ShowF (pr (cn "
typechecking (fn " (shen.app (shen.deref V4336 V4337) ")
" shen.a)) (stoutput)) V4337 V4338 V4339 V4340)))) false)) false) C3754)))

(defun shen.rectify-type (V4341) (shen.demodulate (shen.curry-type V4341)))

(defun shen.demodulate (V4342) (trap-error (let Demod (shen.walk (lambda Y (shen.demod Y)) V4342) (if (= Demod V4342) V4342 (shen.demodulate Demod))) (lambda E V4342)))

(defun shen.curry-type (V4343) (cond ((and (cons? V4343) (and (cons? (tl V4343)) (and (= --> (hd (tl V4343))) (and (cons? (tl (tl V4343))) (and (cons? (tl (tl (tl V4343)))) (= --> (hd (tl (tl (tl V4343)))))))))) (shen.curry-type (cons (hd V4343) (cons --> (cons (tl (tl V4343)) ()))))) ((and (cons? V4343) (and (cons? (tl V4343)) (and (= ==> (hd (tl V4343))) (and (cons? (tl (tl V4343))) (= () (tl (tl (tl V4343)))))))) (shen.curry-type (cons (cons (hd V4343) (cons * (cons A ()))) (cons --> (cons (cons (cons vector (cons boolean ())) (cons --> (cons (cons (hd V4343) (cons * (tl (tl V4343)))) ()))) ()))))) ((and (cons? V4343) (and (cons? (tl V4343)) (and (= * (hd (tl V4343))) (and (cons? (tl (tl V4343))) (and (cons? (tl (tl (tl V4343)))) (= * (hd (tl (tl (tl V4343)))))))))) (shen.curry-type (cons (hd V4343) (cons * (cons (tl (tl V4343)) ()))))) ((cons? V4343) (map (lambda Z (shen.curry-type Z)) V4343)) (true V4343)))

(defun shen.curry (V4344) (cond ((and (cons? V4344) (and (= define (hd V4344)) (cons? (tl V4344)))) V4344) ((and (cons? V4344) (and (= type (hd V4344)) (and (cons? (tl V4344)) (and (cons? (tl (tl V4344))) (= () (tl (tl (tl V4344)))))))) (cons type (cons (shen.curry (hd (tl V4344))) (tl (tl V4344))))) ((and (cons? V4344) (and (= input+ (hd V4344)) (and (cons? (tl V4344)) (and (cons? (tl (tl V4344))) (= () (tl (tl (tl V4344)))))))) (cons input+ (cons (hd (tl V4344)) (cons (shen.curry (hd (tl (tl V4344)))) ())))) ((and (cons? V4344) (shen.special? (hd V4344))) (cons (hd V4344) (map (lambda Y (shen.curry Y)) (tl V4344)))) ((and (cons? V4344) (shen.extraspecial? (hd V4344))) V4344) ((and (cons? V4344) (and (cons? (tl V4344)) (cons? (tl (tl V4344))))) (shen.curry (cons (cons (hd V4344) (cons (hd (tl V4344)) ())) (tl (tl V4344))))) ((and (cons? V4344) (and (cons? (tl V4344)) (= () (tl (tl V4344))))) (cons (shen.curry (hd V4344)) (cons (shen.curry (hd (tl V4344))) ()))) (true V4344)))

(defun shen.special? (V4345) (element? V4345 (value shen.*special*)))

(defun shen.extraspecial? (V4346) (element? V4346 (value shen.*extraspecial*)))

(defun shen.system-S (V4347 V4348 V4349 V4350 V4351 V4352) (let K3759 (+ V4351 1) (let C3763 (if (shen.unlocked? V4350) (do (shen.incinfs) (when (shen.maxinfexceeded?) V4349 V4350 K3759 V4352)) false) (if (= C3763 false) (let C3764 (if (shen.unlocked? V4350) (let Tm3765 (shen.lazyderef V4347 V4349) (if (cons? Tm3765) (let X (hd Tm3765) (let Tm3766 (shen.lazyderef (tl Tm3765) V4349) (if (cons? Tm3766) (let Colon (hd Tm3766) (let Tm3767 (shen.lazyderef (tl Tm3766) V4349) (if (cons? Tm3767) (let A (hd Tm3767) (let Tm3768 (shen.lazyderef (tl Tm3767) V4349) (if (= Tm3768 ()) (do (shen.incinfs) (when (= (shen.deref Colon V4349) (intern ":")) V4349 V4350 K3759 (freeze (when (shen.type-theory-enabled?) V4349 V4350 K3759 (freeze (shen.cut V4349 V4350 K3759 (freeze (shen.system-S-h X A V4348 V4349 V4350 K3759 V4352)))))))) false))) false))) false))) false)) false) (if (= C3764 false) (let C3769 (if (shen.unlocked? V4350) (do (shen.incinfs) (when (value shen.*spy*) V4349 V4350 K3759 (freeze (shen.show V4347 V4348 V4349 V4350 K3759 V4352)))) false) (if (= C3769 false) (let C3770 (if (shen.unlocked? V4350) (do (shen.incinfs) (shen.search-user-datatypes V4347 V4348 (value shen.*datatypes*) V4349 V4350 K3759 V4352)) false) (if (= C3770 false) (shen.unlock V4350 K3759) C3770)) C3769)) C3764)) C3763))))

(defun shen.show (V4359 V4360 V4361 V4362 V4363 V4364) (do (shen.line) (do (shen.show-p (shen.deref V4359 V4361)) (do (nl 2) (do (shen.show-assumptions (shen.deref V4360 V4361) 1) (do (shen.pause-for-user) false))))))

(defun shen.line () (let Infs (inferences) (pr (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V4365) (cond ((and (cons? V4365) (and (cons? (tl V4365)) (and (cons? (tl (tl V4365))) (and (= () (tl (tl (tl V4365)))) (= (hd (tl V4365)) (intern ":")))))) (do (shen.prterm (hd V4365)) (do (pr " : " (stoutput)) (pr (shen.app (hd (tl (tl V4365))) "" shen.r) (stoutput))))) (true (shen.prterm V4365))))

(defun shen.prterm (V4366) (cond ((and (cons? V4366) (and (= cons (hd V4366)) (and (cons? (tl V4366)) (and (cons? (tl (tl V4366))) (= () (tl (tl (tl V4366)))))))) (do (pr "[" (stoutput)) (do (shen.prterm (hd (tl V4366))) (do (shen.prtl (hd (tl (tl V4366)))) (pr "]" (stoutput)))))) ((cons? V4366) (do (pr "(" (stoutput)) (do (shen.prterm (hd V4366)) (do (map (lambda Y (do (pr " " (stoutput)) (shen.prterm Y))) (tl V4366)) (pr ")" (stoutput)))))) (true (print V4366))))

(defun shen.prtl (V4367) (cond ((= () V4367) "") ((and (cons? V4367) (and (= cons (hd V4367)) (and (cons? (tl V4367)) (and (cons? (tl (tl V4367))) (= () (tl (tl (tl V4367)))))))) (do (pr " " (stoutput)) (do (shen.prterm (hd (tl V4367))) (shen.prtl (hd (tl (tl V4367))))))) (true (do (pr " | " (stoutput)) (shen.prterm V4367)))))

(defun shen.show-assumptions (V4374 V4375) (cond ((= () V4374) (pr "
> " (stoutput))) ((cons? V4374) (do (pr (shen.app V4375 ". " shen.a) (stoutput)) (do (shen.show-p (hd V4374)) (do (nl 1) (shen.show-assumptions (tl V4374) (+ V4375 1)))))) (true (simple-error "implementation error in shen.show-assumptions"))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun shen.maxinfexceeded? () (if (> (inferences) (value shen.*maxinferences*)) (simple-error "maximum inferences exceeded") false))

(defun shen.system-S-h (V4376 V4377 V4378 V4379 V4380 V4381 V4382) (let K3774 (+ V4381 1) (let C3779 (if (shen.unlocked? V4380) (do (shen.incinfs) (when (value shen.*spy*) V4379 V4380 K3774 (freeze (shen.show (cons V4376 (cons (intern ":") (cons V4377 ()))) V4378 V4379 V4380 K3774 V4382)))) false) (if (= C3779 false) (let C3780 (if (shen.unlocked? V4380) (do (shen.incinfs) (when (not (cons? (shen.lazyderef V4376 V4379))) V4379 V4380 K3774 (freeze (shen.primitive V4376 V4377 V4379 V4380 K3774 V4382)))) false) (if (= C3780 false) (let C3781 (if (shen.unlocked? V4380) (do (shen.incinfs) (shen.by-hypothesis V4376 V4377 V4378 V4379 V4380 K3774 V4382)) false) (if (= C3781 false) (let C3782 (if (shen.unlocked? V4380) (let Tm3783 (shen.lazyderef V4376 V4379) (if (cons? Tm3783) (let F (hd Tm3783) (let Tm3784 (shen.lazyderef (tl Tm3783) V4379) (if (= Tm3784 ()) (do (shen.incinfs) (shen.lookupsig F (cons --> (cons V4377 ())) V4379 V4380 K3774 V4382)) false))) false)) false) (if (= C3782 false) (let C3785 (if (shen.unlocked? V4380) (let Tm3786 (shen.lazyderef V4376 V4379) (if (cons? Tm3786) (let Tm3787 (shen.lazyderef (hd Tm3786) V4379) (if (= Tm3787 fn) (let Tm3788 (shen.lazyderef (tl Tm3786) V4379) (if (cons? Tm3788) (let F (hd Tm3788) (let Tm3789 (shen.lazyderef (tl Tm3788) V4379) (if (= Tm3789 ()) (do (shen.incinfs) (shen.lookupsig F V4377 V4379 V4380 K3774 V4382)) false))) false)) false)) false)) false) (if (= C3785 false) (let C3790 (if (shen.unlocked? V4380) (let Tm3791 (shen.lazyderef V4376 V4379) (if (cons? Tm3791) (let F (hd Tm3791) (let Tm3792 (shen.lazyderef (tl Tm3791) V4379) (if (cons? Tm3792) (let X (hd Tm3792) (let Tm3793 (shen.lazyderef (tl Tm3792) V4379) (if (= Tm3793 ()) (let B (shen.newpv V4379) (shen.gc V4379 (do (shen.incinfs) (when (not (cons? (shen.lazyderef F V4379))) V4379 V4380 K3774 (freeze (shen.lookupsig F (cons B (cons --> (cons V4377 ()))) V4379 V4380 K3774 (freeze (shen.system-S-h X B V4378 V4379 V4380 K3774 V4382)))))))) false))) false))) false)) false) (if (= C3790 false) (let C3794 (if (shen.unlocked? V4380) (let Tm3795 (shen.lazyderef V4376 V4379) (if (cons? Tm3795) (let F (hd Tm3795) (let Tm3796 (shen.lazyderef (tl Tm3795) V4379) (if (cons? Tm3796) (let X (hd Tm3796) (let Tm3797 (shen.lazyderef (tl Tm3796) V4379) (if (= Tm3797 ()) (let B (shen.newpv V4379) (shen.gc V4379 (do (shen.incinfs) (shen.system-S-h F (cons B (cons --> (cons V4377 ()))) V4378 V4379 V4380 K3774 (freeze (shen.system-S-h X B V4378 V4379 V4380 K3774 V4382)))))) false))) false))) false)) false) (if (= C3794 false) (let C3798 (if (shen.unlocked? V4380) (let Tm3799 (shen.lazyderef V4376 V4379) (if (cons? Tm3799) (let Tm3800 (shen.lazyderef (hd Tm3799) V4379) (if (= Tm3800 cons) (let Tm3801 (shen.lazyderef (tl Tm3799) V4379) (if (cons? Tm3801) (let X (hd Tm3801) (let Tm3802 (shen.lazyderef (tl Tm3801) V4379) (if (cons? Tm3802) (let Y (hd Tm3802) (let Tm3803 (shen.lazyderef (tl Tm3802) V4379) (if (= Tm3803 ()) (let Tm3804 (shen.lazyderef V4377 V4379) (let GoTo3805 (lambda A (do (shen.incinfs) (shen.system-S-h X A V4378 V4379 V4380 K3774 (freeze (shen.system-S-h Y (cons list (cons A ())) V4378 V4379 V4380 K3774 V4382))))) (if (cons? Tm3804) (let Tm3806 (shen.lazyderef (hd Tm3804) V4379) (let GoTo3807 (freeze (let Tm3808 (shen.lazyderef (tl Tm3804) V4379) (let GoTo3809 (lambda A (GoTo3805 A)) (if (cons? Tm3808) (let A (hd Tm3808) (let Tm3810 (shen.lazyderef (tl Tm3808) V4379) (let GoTo3811 (freeze (GoTo3809 A)) (if (= Tm3810 ()) (thaw GoTo3811) (if (shen.pvar? Tm3810) (shen.bind! Tm3810 () V4379 GoTo3811) false))))) (if (shen.pvar? Tm3808) (let A (shen.newpv V4379) (shen.gc V4379 (shen.bind! Tm3808 (cons A ()) V4379 (freeze (GoTo3809 A))))) false))))) (if (= Tm3806 list) (thaw GoTo3807) (if (shen.pvar? Tm3806) (shen.bind! Tm3806 list V4379 GoTo3807) false)))) (if (shen.pvar? Tm3804) (let A (shen.newpv V4379) (shen.gc V4379 (shen.bind! Tm3804 (cons list (cons A ())) V4379 (freeze (GoTo3805 A))))) false)))) false))) false))) false)) false)) false)) false) (if (= C3798 false) (let C3812 (if (shen.unlocked? V4380) (let Tm3813 (shen.lazyderef V4376 V4379) (if (cons? Tm3813) (let Tm3814 (shen.lazyderef (hd Tm3813) V4379) (if (= Tm3814 @p) (let Tm3815 (shen.lazyderef (tl Tm3813) V4379) (if (cons? Tm3815) (let X (hd Tm3815) (let Tm3816 (shen.lazyderef (tl Tm3815) V4379) (if (cons? Tm3816) (let Y (hd Tm3816) (let Tm3817 (shen.lazyderef (tl Tm3816) V4379) (if (= Tm3817 ()) (let Tm3818 (shen.lazyderef V4377 V4379) (let GoTo3819 (lambda A (lambda B (do (shen.incinfs) (shen.system-S-h X A V4378 V4379 V4380 K3774 (freeze (shen.system-S-h Y B V4378 V4379 V4380 K3774 V4382)))))) (if (cons? Tm3818) (let A (hd Tm3818) (let Tm3820 (shen.lazyderef (tl Tm3818) V4379) (let GoTo3821 (lambda B ((GoTo3819 A) B)) (if (cons? Tm3820) (let Tm3822 (shen.lazyderef (hd Tm3820) V4379) (let GoTo3823 (freeze (let Tm3824 (shen.lazyderef (tl Tm3820) V4379) (let GoTo3825 (lambda B (GoTo3821 B)) (if (cons? Tm3824) (let B (hd Tm3824) (let Tm3826 (shen.lazyderef (tl Tm3824) V4379) (let GoTo3827 (freeze (GoTo3825 B)) (if (= Tm3826 ()) (thaw GoTo3827) (if (shen.pvar? Tm3826) (shen.bind! Tm3826 () V4379 GoTo3827) false))))) (if (shen.pvar? Tm3824) (let B (shen.newpv V4379) (shen.gc V4379 (shen.bind! Tm3824 (cons B ()) V4379 (freeze (GoTo3825 B))))) false))))) (if (= Tm3822 *) (thaw GoTo3823) (if (shen.pvar? Tm3822) (shen.bind! Tm3822 * V4379 GoTo3823) false)))) (if (shen.pvar? Tm3820) (let B (shen.newpv V4379) (shen.gc V4379 (shen.bind! Tm3820 (cons * (cons B ())) V4379 (freeze (GoTo3821 B))))) false))))) (if (shen.pvar? Tm3818) (let A (shen.newpv V4379) (shen.gc V4379 (let B (shen.newpv V4379) (shen.gc V4379 (shen.bind! Tm3818 (cons A (cons * (cons B ()))) V4379 (freeze ((GoTo3819 A) B))))))) false)))) false))) false))) false)) false)) false)) false) (if (= C3812 false) (let C3828 (if (shen.unlocked? V4380) (let Tm3829 (shen.lazyderef V4376 V4379) (if (cons? Tm3829) (let Tm3830 (shen.lazyderef (hd Tm3829) V4379) (if (= Tm3830 @v) (let Tm3831 (shen.lazyderef (tl Tm3829) V4379) (if (cons? Tm3831) (let X (hd Tm3831) (let Tm3832 (shen.lazyderef (tl Tm3831) V4379) (if (cons? Tm3832) (let Y (hd Tm3832) (let Tm3833 (shen.lazyderef (tl Tm3832) V4379) (if (= Tm3833 ()) (let Tm3834 (shen.lazyderef V4377 V4379) (let GoTo3835 (lambda A (do (shen.incinfs) (shen.system-S-h X A V4378 V4379 V4380 K3774 (freeze (shen.system-S-h Y (cons vector (cons A ())) V4378 V4379 V4380 K3774 V4382))))) (if (cons? Tm3834) (let Tm3836 (shen.lazyderef (hd Tm3834) V4379) (let GoTo3837 (freeze (let Tm3838 (shen.lazyderef (tl Tm3834) V4379) (let GoTo3839 (lambda A (GoTo3835 A)) (if (cons? Tm3838) (let A (hd Tm3838) (let Tm3840 (shen.lazyderef (tl Tm3838) V4379) (let GoTo3841 (freeze (GoTo3839 A)) (if (= Tm3840 ()) (thaw GoTo3841) (if (shen.pvar? Tm3840) (shen.bind! Tm3840 () V4379 GoTo3841) false))))) (if (shen.pvar? Tm3838) (let A (shen.newpv V4379) (shen.gc V4379 (shen.bind! Tm3838 (cons A ()) V4379 (freeze (GoTo3839 A))))) false))))) (if (= Tm3836 vector) (thaw GoTo3837) (if (shen.pvar? Tm3836) (shen.bind! Tm3836 vector V4379 GoTo3837) false)))) (if (shen.pvar? Tm3834) (let A (shen.newpv V4379) (shen.gc V4379 (shen.bind! Tm3834 (cons vector (cons A ())) V4379 (freeze (GoTo3835 A))))) false)))) false))) false))) false)) false)) false)) false) (if (= C3828 false) (let C3842 (if (shen.unlocked? V4380) (let Tm3843 (shen.lazyderef V4376 V4379) (if (cons? Tm3843) (let Tm3844 (shen.lazyderef (hd Tm3843) V4379) (if (= Tm3844 @s) (let Tm3845 (shen.lazyderef (tl Tm3843) V4379) (if (cons? Tm3845) (let X (hd Tm3845) (let Tm3846 (shen.lazyderef (tl Tm3845) V4379) (if (cons? Tm3846) (let Y (hd Tm3846) (let Tm3847 (shen.lazyderef (tl Tm3846) V4379) (if (= Tm3847 ()) (let Tm3848 (shen.lazyderef V4377 V4379) (let GoTo3849 (freeze (do (shen.incinfs) (shen.system-S-h X string V4378 V4379 V4380 K3774 (freeze (shen.system-S-h Y string V4378 V4379 V4380 K3774 V4382))))) (if (= Tm3848 string) (thaw GoTo3849) (if (shen.pvar? Tm3848) (shen.bind! Tm3848 string V4379 GoTo3849) false)))) false))) false))) false)) false)) false)) false) (if (= C3842 false) (let C3850 (if (shen.unlocked? V4380) (let Tm3851 (shen.lazyderef V4376 V4379) (if (cons? Tm3851) (let Tm3852 (shen.lazyderef (hd Tm3851) V4379) (if (= Tm3852 lambda) (let Tm3853 (shen.lazyderef (tl Tm3851) V4379) (if (cons? Tm3853) (let X (hd Tm3853) (let Tm3854 (shen.lazyderef (tl Tm3853) V4379) (if (cons? Tm3854) (let Y (hd Tm3854) (let Tm3855 (shen.lazyderef (tl Tm3854) V4379) (if (= Tm3855 ()) (let Tm3856 (shen.lazyderef V4377 V4379) (let GoTo3857 (lambda A (lambda B (let Z (shen.newpv V4379) (shen.gc V4379 (let New (shen.newpv V4379) (shen.gc V4379 (do (shen.incinfs) (bind New (shen.freshterm (shen.lazyderef X V4379)) V4379 V4380 K3774 (freeze (bind Z (shen.beta (shen.lazyderef X V4379) (shen.deref New V4379) (shen.deref Y V4379)) V4379 V4380 K3774 (freeze (shen.system-S-h Z B (cons (cons New (cons (intern ":") (cons A ()))) V4378) V4379 V4380 K3774 V4382)))))))))))) (if (cons? Tm3856) (let A (hd Tm3856) (let Tm3858 (shen.lazyderef (tl Tm3856) V4379) (let GoTo3859 (lambda B ((GoTo3857 A) B)) (if (cons? Tm3858) (let Tm3860 (shen.lazyderef (hd Tm3858) V4379) (let GoTo3861 (freeze (let Tm3862 (shen.lazyderef (tl Tm3858) V4379) (let GoTo3863 (lambda B (GoTo3859 B)) (if (cons? Tm3862) (let B (hd Tm3862) (let Tm3864 (shen.lazyderef (tl Tm3862) V4379) (let GoTo3865 (freeze (GoTo3863 B)) (if (= Tm3864 ()) (thaw GoTo3865) (if (shen.pvar? Tm3864) (shen.bind! Tm3864 () V4379 GoTo3865) false))))) (if (shen.pvar? Tm3862) (let B (shen.newpv V4379) (shen.gc V4379 (shen.bind! Tm3862 (cons B ()) V4379 (freeze (GoTo3863 B))))) false))))) (if (= Tm3860 -->) (thaw GoTo3861) (if (shen.pvar? Tm3860) (shen.bind! Tm3860 --> V4379 GoTo3861) false)))) (if (shen.pvar? Tm3858) (let B (shen.newpv V4379) (shen.gc V4379 (shen.bind! Tm3858 (cons --> (cons B ())) V4379 (freeze (GoTo3859 B))))) false))))) (if (shen.pvar? Tm3856) (let A (shen.newpv V4379) (shen.gc V4379 (let B (shen.newpv V4379) (shen.gc V4379 (shen.bind! Tm3856 (cons A (cons --> (cons B ()))) V4379 (freeze ((GoTo3857 A) B))))))) false)))) false))) false))) false)) false)) false)) false) (if (= C3850 false) (let C3866 (if (shen.unlocked? V4380) (let Tm3867 (shen.lazyderef V4376 V4379) (if (cons? Tm3867) (let Tm3868 (shen.lazyderef (hd Tm3867) V4379) (if (= Tm3868 let) (let Tm3869 (shen.lazyderef (tl Tm3867) V4379) (if (cons? Tm3869) (let X (hd Tm3869) (let Tm3870 (shen.lazyderef (tl Tm3869) V4379) (if (cons? Tm3870) (let Y (hd Tm3870) (let Tm3871 (shen.lazyderef (tl Tm3870) V4379) (if (cons? Tm3871) (let Z (hd Tm3871) (let Tm3872 (shen.lazyderef (tl Tm3871) V4379) (if (= Tm3872 ()) (let W (shen.newpv V4379) (shen.gc V4379 (let New (shen.newpv V4379) (shen.gc V4379 (let B (shen.newpv V4379) (shen.gc V4379 (do (shen.incinfs) (shen.system-S-h Y B V4378 V4379 V4380 K3774 (freeze (bind New (shen.freshterm (shen.lazyderef X V4379)) V4379 V4380 K3774 (freeze (bind W (shen.beta (shen.lazyderef X V4379) (shen.lazyderef New V4379) (shen.lazyderef Z V4379)) V4379 V4380 K3774 (freeze (shen.system-S-h W V4377 (cons (cons New (cons (intern ":") (cons B ()))) V4378) V4379 V4380 K3774 V4382)))))))))))))) false))) false))) false))) false)) false)) false)) false) (if (= C3866 false) (let C3873 (if (shen.unlocked? V4380) (let Tm3874 (shen.lazyderef V4376 V4379) (if (cons? Tm3874) (let Tm3875 (shen.lazyderef (hd Tm3874) V4379) (if (= Tm3875 open) (let Tm3876 (shen.lazyderef (tl Tm3874) V4379) (if (cons? Tm3876) (let File (hd Tm3876) (let Tm3877 (shen.lazyderef (tl Tm3876) V4379) (if (cons? Tm3877) (let V3771 (hd Tm3877) (let Tm3878 (shen.lazyderef (tl Tm3877) V4379) (if (= Tm3878 ()) (let Tm3879 (shen.lazyderef V4377 V4379) (let GoTo3880 (lambda D (do (shen.incinfs) (is! V3771 D V4379 V4380 K3774 (freeze (when (element? (shen.lazyderef D V4379) (cons in (cons out ()))) V4379 V4380 K3774 (freeze (shen.system-S-h File string V4378 V4379 V4380 K3774 V4382))))))) (if (cons? Tm3879) (let Tm3881 (shen.lazyderef (hd Tm3879) V4379) (let GoTo3882 (freeze (let Tm3883 (shen.lazyderef (tl Tm3879) V4379) (let GoTo3884 (lambda D (GoTo3880 D)) (if (cons? Tm3883) (let D (hd Tm3883) (let Tm3885 (shen.lazyderef (tl Tm3883) V4379) (let GoTo3886 (freeze (GoTo3884 D)) (if (= Tm3885 ()) (thaw GoTo3886) (if (shen.pvar? Tm3885) (shen.bind! Tm3885 () V4379 GoTo3886) false))))) (if (shen.pvar? Tm3883) (let D (shen.newpv V4379) (shen.gc V4379 (shen.bind! Tm3883 (cons D ()) V4379 (freeze (GoTo3884 D))))) false))))) (if (= Tm3881 stream) (thaw GoTo3882) (if (shen.pvar? Tm3881) (shen.bind! Tm3881 stream V4379 GoTo3882) false)))) (if (shen.pvar? Tm3879) (let D (shen.newpv V4379) (shen.gc V4379 (shen.bind! Tm3879 (cons stream (cons D ())) V4379 (freeze (GoTo3880 D))))) false)))) false))) false))) false)) false)) false)) false) (if (= C3873 false) (let C3887 (if (shen.unlocked? V4380) (let Tm3888 (shen.lazyderef V4376 V4379) (if (cons? Tm3888) (let Tm3889 (shen.lazyderef (hd Tm3888) V4379) (if (= Tm3889 type) (let Tm3890 (shen.lazyderef (tl Tm3888) V4379) (if (cons? Tm3890) (let X (hd Tm3890) (let Tm3891 (shen.lazyderef (tl Tm3890) V4379) (if (cons? Tm3891) (let A (hd Tm3891) (let Tm3892 (shen.lazyderef (tl Tm3891) V4379) (if (= Tm3892 ()) (do (shen.incinfs) (shen.cut V4379 V4380 K3774 (freeze (is! (shen.rectify-type (shen.deref A V4379)) V4377 V4379 V4380 K3774 (freeze (shen.system-S-h X V4377 V4378 V4379 V4380 K3774 V4382)))))) false))) false))) false)) false)) false)) false) (if (= C3887 false) (let C3893 (if (shen.unlocked? V4380) (let Tm3894 (shen.lazyderef V4376 V4379) (if (cons? Tm3894) (let Tm3895 (shen.lazyderef (hd Tm3894) V4379) (if (= Tm3895 input+) (let Tm3896 (shen.lazyderef (tl Tm3894) V4379) (if (cons? Tm3896) (let A (hd Tm3896) (let Tm3897 (shen.lazyderef (tl Tm3896) V4379) (if (cons? Tm3897) (let Stream (hd Tm3897) (let Tm3898 (shen.lazyderef (tl Tm3897) V4379) (if (= Tm3898 ()) (do (shen.incinfs) (is! V4377 (shen.rectify-type (shen.deref A V4379)) V4379 V4380 K3774 (freeze (shen.system-S-h Stream (cons stream (cons in ())) V4378 V4379 V4380 K3774 V4382)))) false))) false))) false)) false)) false)) false) (if (= C3893 false) (let C3899 (if (shen.unlocked? V4380) (let Tm3900 (shen.lazyderef V4376 V4379) (if (cons? Tm3900) (let Tm3901 (shen.lazyderef (hd Tm3900) V4379) (if (= Tm3901 set) (let Tm3902 (shen.lazyderef (tl Tm3900) V4379) (if (cons? Tm3902) (let Var (hd Tm3902) (let Tm3903 (shen.lazyderef (tl Tm3902) V4379) (if (cons? Tm3903) (let Val (hd Tm3903) (let Tm3904 (shen.lazyderef (tl Tm3903) V4379) (if (= Tm3904 ()) (do (shen.incinfs) (shen.system-S-h Var symbol V4378 V4379 V4380 K3774 (freeze (shen.system-S-h (cons value (cons Var ())) V4377 V4378 V4379 V4380 K3774 (freeze (shen.system-S-h Val V4377 V4378 V4379 V4380 K3774 V4382)))))) false))) false))) false)) false)) false)) false) (if (= C3899 false) (let C3905 (if (shen.unlocked? V4380) (let Normalised (shen.newpv V4379) (shen.gc V4379 (do (shen.incinfs) (shen.l-rules V4378 Normalised false V4379 V4380 K3774 (freeze (shen.cut V4379 V4380 K3774 (freeze (shen.system-S-h V4376 V4377 Normalised V4379 V4380 K3774 V4382)))))))) false) (if (= C3905 false) (let C3906 (if (shen.unlocked? V4380) (do (shen.incinfs) (shen.search-user-datatypes (cons V4376 (cons (intern ":") (cons V4377 ()))) V4378 (value shen.*datatypes*) V4379 V4380 K3774 V4382)) false) (if (= C3906 false) (shen.unlock V4380 K3774) C3906)) C3905)) C3899)) C3893)) C3887)) C3873)) C3866)) C3850)) C3842)) C3828)) C3812)) C3798)) C3794)) C3790)) C3785)) C3782)) C3781)) C3780)) C3779))))

(defun shen.primitive (V4383 V4384 V4385 V4386 V4387 V4388) (let C3913 (if (shen.unlocked? V4386) (let Tm3914 (shen.lazyderef V4384 V4385) (let GoTo3915 (freeze (do (shen.incinfs) (when (number? (shen.lazyderef V4383 V4385)) V4385 V4386 V4387 V4388))) (if (= Tm3914 number) (thaw GoTo3915) (if (shen.pvar? Tm3914) (shen.bind! Tm3914 number V4385 GoTo3915) false)))) false) (if (= C3913 false) (let C3916 (if (shen.unlocked? V4386) (let Tm3917 (shen.lazyderef V4384 V4385) (let GoTo3918 (freeze (do (shen.incinfs) (when (boolean? (shen.lazyderef V4383 V4385)) V4385 V4386 V4387 V4388))) (if (= Tm3917 boolean) (thaw GoTo3918) (if (shen.pvar? Tm3917) (shen.bind! Tm3917 boolean V4385 GoTo3918) false)))) false) (if (= C3916 false) (let C3919 (if (shen.unlocked? V4386) (let Tm3920 (shen.lazyderef V4384 V4385) (let GoTo3921 (freeze (do (shen.incinfs) (when (string? (shen.lazyderef V4383 V4385)) V4385 V4386 V4387 V4388))) (if (= Tm3920 string) (thaw GoTo3921) (if (shen.pvar? Tm3920) (shen.bind! Tm3920 string V4385 GoTo3921) false)))) false) (if (= C3919 false) (let C3922 (if (shen.unlocked? V4386) (let Tm3923 (shen.lazyderef V4384 V4385) (let GoTo3924 (freeze (do (shen.incinfs) (when (symbol? (shen.lazyderef V4383 V4385)) V4385 V4386 V4387 V4388))) (if (= Tm3923 symbol) (thaw GoTo3924) (if (shen.pvar? Tm3923) (shen.bind! Tm3923 symbol V4385 GoTo3924) false)))) false) (if (= C3922 false) (if (shen.unlocked? V4386) (let Tm3925 (shen.lazyderef V4383 V4385) (if (= Tm3925 ()) (let Tm3926 (shen.lazyderef V4384 V4385) (let GoTo3927 (lambda A (do (shen.incinfs) (thaw V4388))) (if (cons? Tm3926) (let Tm3928 (shen.lazyderef (hd Tm3926) V4385) (let GoTo3929 (freeze (let Tm3930 (shen.lazyderef (tl Tm3926) V4385) (let GoTo3931 (lambda A (GoTo3927 A)) (if (cons? Tm3930) (let A (hd Tm3930) (let Tm3932 (shen.lazyderef (tl Tm3930) V4385) (let GoTo3933 (freeze (GoTo3931 A)) (if (= Tm3932 ()) (thaw GoTo3933) (if (shen.pvar? Tm3932) (shen.bind! Tm3932 () V4385 GoTo3933) false))))) (if (shen.pvar? Tm3930) (let A (shen.newpv V4385) (shen.gc V4385 (shen.bind! Tm3930 (cons A ()) V4385 (freeze (GoTo3931 A))))) false))))) (if (= Tm3928 list) (thaw GoTo3929) (if (shen.pvar? Tm3928) (shen.bind! Tm3928 list V4385 GoTo3929) false)))) (if (shen.pvar? Tm3926) (let A (shen.newpv V4385) (shen.gc V4385 (shen.bind! Tm3926 (cons list (cons A ())) V4385 (freeze (GoTo3927 A))))) false)))) false)) false) C3922)) C3919)) C3916)) C3913)))

(defun shen.by-hypothesis (V4389 V4390 V4391 V4392 V4393 V4394 V4395) (let C3941 (if (shen.unlocked? V4393) (let Tm3942 (shen.lazyderef V4391 V4392) (if (cons? Tm3942) (let Tm3943 (shen.lazyderef (hd Tm3942) V4392) (if (cons? Tm3943) (let Y (hd Tm3943) (let Tm3944 (shen.lazyderef (tl Tm3943) V4392) (if (cons? Tm3944) (let Colon (hd Tm3944) (let Tm3945 (shen.lazyderef (tl Tm3944) V4392) (if (cons? Tm3945) (let B (hd Tm3945) (let Tm3946 (shen.lazyderef (tl Tm3945) V4392) (if (= Tm3946 ()) (do (shen.incinfs) (when (= (shen.deref Colon V4392) (intern ":")) V4392 V4393 V4394 (freeze (when (= (shen.deref V4389 V4392) (shen.deref Y V4392)) V4392 V4393 V4394 (freeze (is! V4390 B V4392 V4393 V4394 V4395)))))) false))) false))) false))) false)) false)) false) (if (= C3941 false) (if (shen.unlocked? V4393) (let Tm3947 (shen.lazyderef V4391 V4392) (if (cons? Tm3947) (let Hyp (tl Tm3947) (do (shen.incinfs) (shen.by-hypothesis V4389 V4390 Hyp V4392 V4393 V4394 V4395))) false)) false) C3941)))

(defun shen.lookupsig (V4396 V4397 V4398 V4399 V4400 V4401) (if (shen.unlocked? V4399) (do (shen.incinfs) (shen.sigf (assoc V4396 (value shen.*sigf*)) V4397 V4398 V4399 V4400 V4401)) false))

(defun shen.sigf (V4416 V4417 V4418 V4419 V4420 V4421) (cond ((cons? V4416) ((((((tl V4416) V4417) V4418) V4419) V4420) V4421)) (true false)))

(defun shen.freshterm (V4422) (let V (absvector 3) (let V0 (address-> V 0 shen.print-freshterm) (let V1 (address-> V0 1 V4422) (let V2 (address-> V1 2 (set shen.*gensym* (+ 1 (value shen.*gensym*)))) V2)))))

(defun shen.print-freshterm (V4423) (cn "&&" (str (<-address V4423 1))))

(defun shen.search-user-datatypes (V4424 V4425 V4426 V4427 V4428 V4429 V4430) (let C3961 (if (shen.unlocked? V4428) (let Tm3962 (shen.lazyderef V4426 V4427) (if (cons? Tm3962) (let Tm3963 (shen.lazyderef (hd Tm3962) V4427) (if (cons? Tm3963) (let Fn (tl Tm3963) (do (shen.incinfs) (call (((shen.deref Fn V4427) (shen.deref V4424 V4427)) (shen.deref V4425 V4427)) V4427 V4428 V4429 V4430))) false)) false)) false) (if (= C3961 false) (if (shen.unlocked? V4428) (let Tm3964 (shen.lazyderef V4426 V4427) (if (cons? Tm3964) (let Ds (tl Tm3964) (do (shen.incinfs) (shen.search-user-datatypes V4424 V4425 Ds V4427 V4428 V4429 V4430))) false)) false) C3961)))

(defun shen.l-rules (V4431 V4432 V4433 V4434 V4435 V4436 V4437) (let K3967 (+ V4436 1) (let C3972 (if (shen.unlocked? V4435) (let Tm3973 (shen.lazyderef V4431 V4434) (if (= Tm3973 ()) (let Tm3974 (shen.lazyderef V4433 V4434) (if (= Tm3974 true) (do (shen.incinfs) (shen.cut V4434 V4435 K3967 (freeze (bind V4432 () V4434 V4435 K3967 V4437)))) false)) false)) false) (if (= C3972 false) (let C3975 (if (shen.unlocked? V4435) (let Tm3976 (shen.lazyderef V4431 V4434) (if (cons? Tm3976) (let Tm3977 (shen.lazyderef (hd Tm3976) V4434) (if (cons? Tm3977) (let Tm3978 (shen.lazyderef (hd Tm3977) V4434) (if (cons? Tm3978) (let Tm3979 (shen.lazyderef (hd Tm3978) V4434) (if (= Tm3979 cons) (let Tm3980 (shen.lazyderef (tl Tm3978) V4434) (if (cons? Tm3980) (let X (hd Tm3980) (let Tm3981 (shen.lazyderef (tl Tm3980) V4434) (if (cons? Tm3981) (let Y (hd Tm3981) (let Tm3982 (shen.lazyderef (tl Tm3981) V4434) (if (= Tm3982 ()) (let Tm3983 (shen.lazyderef (tl Tm3977) V4434) (if (cons? Tm3983) (let Colon (hd Tm3983) (let Tm3984 (shen.lazyderef (tl Tm3983) V4434) (if (cons? Tm3984) (let Tm3985 (shen.lazyderef (hd Tm3984) V4434) (if (cons? Tm3985) (let Tm3986 (shen.lazyderef (hd Tm3985) V4434) (if (= Tm3986 list) (let Tm3987 (shen.lazyderef (tl Tm3985) V4434) (if (cons? Tm3987) (let A (hd Tm3987) (let Tm3988 (shen.lazyderef (tl Tm3987) V4434) (if (= Tm3988 ()) (let Tm3989 (shen.lazyderef (tl Tm3984) V4434) (if (= Tm3989 ()) (let Hyp (tl Tm3976) (do (shen.incinfs) (when (= (shen.deref Colon V4434) (intern ":")) V4434 V4435 K3967 (freeze (shen.cut V4434 V4435 K3967 (freeze (shen.l-rules (cons (cons X (cons Colon (cons A ()))) (cons (cons Y (cons Colon (cons (cons list (cons A ())) ()))) Hyp)) V4432 true V4434 V4435 K3967 V4437))))))) false)) false))) false)) false)) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C3975 false) (let C3990 (if (shen.unlocked? V4435) (let Tm3991 (shen.lazyderef V4431 V4434) (if (cons? Tm3991) (let Tm3992 (shen.lazyderef (hd Tm3991) V4434) (if (cons? Tm3992) (let Tm3993 (shen.lazyderef (hd Tm3992) V4434) (if (cons? Tm3993) (let Tm3994 (shen.lazyderef (hd Tm3993) V4434) (if (= Tm3994 @p) (let Tm3995 (shen.lazyderef (tl Tm3993) V4434) (if (cons? Tm3995) (let X (hd Tm3995) (let Tm3996 (shen.lazyderef (tl Tm3995) V4434) (if (cons? Tm3996) (let Y (hd Tm3996) (let Tm3997 (shen.lazyderef (tl Tm3996) V4434) (if (= Tm3997 ()) (let Tm3998 (shen.lazyderef (tl Tm3992) V4434) (if (cons? Tm3998) (let Colon (hd Tm3998) (let Tm3999 (shen.lazyderef (tl Tm3998) V4434) (if (cons? Tm3999) (let Tm4000 (shen.lazyderef (hd Tm3999) V4434) (if (cons? Tm4000) (let A (hd Tm4000) (let Tm4001 (shen.lazyderef (tl Tm4000) V4434) (if (cons? Tm4001) (let Tm4002 (shen.lazyderef (hd Tm4001) V4434) (if (= Tm4002 *) (let Tm4003 (shen.lazyderef (tl Tm4001) V4434) (if (cons? Tm4003) (let B (hd Tm4003) (let Tm4004 (shen.lazyderef (tl Tm4003) V4434) (if (= Tm4004 ()) (let Tm4005 (shen.lazyderef (tl Tm3999) V4434) (if (= Tm4005 ()) (let Hyp (tl Tm3991) (do (shen.incinfs) (when (= (shen.deref Colon V4434) (intern ":")) V4434 V4435 K3967 (freeze (shen.cut V4434 V4435 K3967 (freeze (shen.l-rules (cons (cons X (cons Colon (cons A ()))) (cons (cons Y (cons Colon (cons B ()))) Hyp)) V4432 true V4434 V4435 K3967 V4437))))))) false)) false))) false)) false)) false))) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C3990 false) (let C4006 (if (shen.unlocked? V4435) (let Tm4007 (shen.lazyderef V4431 V4434) (if (cons? Tm4007) (let Tm4008 (shen.lazyderef (hd Tm4007) V4434) (if (cons? Tm4008) (let Tm4009 (shen.lazyderef (hd Tm4008) V4434) (if (cons? Tm4009) (let Tm4010 (shen.lazyderef (hd Tm4009) V4434) (if (= Tm4010 @s) (let Tm4011 (shen.lazyderef (tl Tm4009) V4434) (if (cons? Tm4011) (let X (hd Tm4011) (let Tm4012 (shen.lazyderef (tl Tm4011) V4434) (if (cons? Tm4012) (let Y (hd Tm4012) (let Tm4013 (shen.lazyderef (tl Tm4012) V4434) (if (= Tm4013 ()) (let Tm4014 (shen.lazyderef (tl Tm4008) V4434) (if (cons? Tm4014) (let Colon (hd Tm4014) (let Tm4015 (shen.lazyderef (tl Tm4014) V4434) (if (cons? Tm4015) (let Tm4016 (shen.lazyderef (hd Tm4015) V4434) (if (= Tm4016 string) (let Tm4017 (shen.lazyderef (tl Tm4015) V4434) (if (= Tm4017 ()) (let Hyp (tl Tm4007) (do (shen.incinfs) (when (= (shen.deref Colon V4434) (intern ":")) V4434 V4435 K3967 (freeze (shen.cut V4434 V4435 K3967 (freeze (shen.l-rules (cons (cons X (cons Colon (cons string ()))) (cons (cons Y (cons Colon (cons string ()))) Hyp)) V4432 true V4434 V4435 K3967 V4437))))))) false)) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C4006 false) (let C4018 (if (shen.unlocked? V4435) (let Tm4019 (shen.lazyderef V4431 V4434) (if (cons? Tm4019) (let Tm4020 (shen.lazyderef (hd Tm4019) V4434) (if (cons? Tm4020) (let Tm4021 (shen.lazyderef (hd Tm4020) V4434) (if (cons? Tm4021) (let Tm4022 (shen.lazyderef (hd Tm4021) V4434) (if (= Tm4022 @v) (let Tm4023 (shen.lazyderef (tl Tm4021) V4434) (if (cons? Tm4023) (let X (hd Tm4023) (let Tm4024 (shen.lazyderef (tl Tm4023) V4434) (if (cons? Tm4024) (let Y (hd Tm4024) (let Tm4025 (shen.lazyderef (tl Tm4024) V4434) (if (= Tm4025 ()) (let Tm4026 (shen.lazyderef (tl Tm4020) V4434) (if (cons? Tm4026) (let Colon (hd Tm4026) (let Tm4027 (shen.lazyderef (tl Tm4026) V4434) (if (cons? Tm4027) (let Tm4028 (shen.lazyderef (hd Tm4027) V4434) (if (cons? Tm4028) (let Tm4029 (shen.lazyderef (hd Tm4028) V4434) (if (= Tm4029 vector) (let Tm4030 (shen.lazyderef (tl Tm4028) V4434) (if (cons? Tm4030) (let A (hd Tm4030) (let Tm4031 (shen.lazyderef (tl Tm4030) V4434) (if (= Tm4031 ()) (let Tm4032 (shen.lazyderef (tl Tm4027) V4434) (if (= Tm4032 ()) (let Hyp (tl Tm4019) (do (shen.incinfs) (when (= (shen.deref Colon V4434) (intern ":")) V4434 V4435 K3967 (freeze (shen.cut V4434 V4435 K3967 (freeze (shen.l-rules (cons (cons X (cons Colon (cons A ()))) (cons (cons Y (cons Colon (cons (cons vector (cons A ())) ()))) Hyp)) V4432 true V4434 V4435 K3967 V4437))))))) false)) false))) false)) false)) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C4018 false) (let C4033 (if (shen.unlocked? V4435) (let Tm4034 (shen.lazyderef V4431 V4434) (if (cons? Tm4034) (let P (hd Tm4034) (let Hyp (tl Tm4034) (let Tm4035 (shen.lazyderef V4432 V4434) (let GoTo4036 (lambda Q (lambda Normalised (do (shen.incinfs) (bind Q P V4434 V4435 K3967 (freeze (shen.l-rules Hyp Normalised V4433 V4434 V4435 K3967 V4437)))))) (if (cons? Tm4035) (let Q (hd Tm4035) (let Normalised (tl Tm4035) ((GoTo4036 Q) Normalised))) (if (shen.pvar? Tm4035) (let Q (shen.newpv V4434) (shen.gc V4434 (let Normalised (shen.newpv V4434) (shen.gc V4434 (shen.bind! Tm4035 (cons Q Normalised) V4434 (freeze ((GoTo4036 Q) Normalised))))))) false)))))) false)) false) (if (= C4033 false) (shen.unlock V4435 K3967) C4033)) C4018)) C4006)) C3990)) C3975)) C3972))))

(defun shen.t* (V4438 V4439 V4440 V4441 V4442 V4443) (let K4039 (+ V4442 1) (let C4043 (if (shen.unlocked? V4441) (let Tm4044 (shen.lazyderef V4438 V4440) (if (cons? Tm4044) (let Tm4045 (shen.lazyderef (hd Tm4044) V4440) (if (= Tm4045 define) (let Tm4046 (shen.lazyderef (tl Tm4044) V4440) (if (cons? Tm4046) (let F (hd Tm4046) (let X (tl Tm4046) (let SigxRules (shen.newpv V4440) (shen.gc V4440 (let Rules (shen.newpv V4440) (shen.gc V4440 (let FreshSig (shen.newpv V4440) (shen.gc V4440 (let Sig (shen.newpv V4440) (shen.gc V4440 (do (shen.incinfs) (shen.cut V4440 V4441 K4039 (freeze (bind SigxRules (shen.sigxrules (cons F X)) V4440 V4441 K4039 (freeze (bind Sig (fst (shen.lazyderef SigxRules V4440)) V4440 V4441 K4039 (freeze (bind Rules (snd (shen.lazyderef SigxRules V4440)) V4440 V4441 K4039 (freeze (bind FreshSig (shen.freshen-sig (shen.deref Sig V4440)) V4440 V4441 K4039 (freeze (shen.t*-rules F Rules FreshSig 1 V4440 V4441 K4039 (freeze (is Sig V4439 V4440 V4441 K4039 V4443)))))))))))))))))))))))) false)) false)) false)) false) (if (= C4043 false) (shen.unlock V4441 K4039) C4043))))

(defun shen.sigxrules (V4444) (compile (lambda X (shen.<sig*rules> X)) V4444))

(defun shen.<sig*rules> (V4445) (let Result (if (shen.non-empty-stream? V4445) (let F (shen.hds V4445) (let News4048 (shen.tls V4445) (if (shen.=hd? News4048 {) (let News4049 (shen.tls News4048) (let Parseshen.<signature> (shen.<signature> News4049) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (shen.=hd? Parseshen.<signature> }) (let News4050 (shen.tls Parseshen.<signature>) (let Parseshen.<rules*> (shen.<rules*> News4050) (if (shen.parse-failure? Parseshen.<rules*>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules*>) (let Rectified (shen.rectify-type (shen.<-out Parseshen.<signature>)) (@p Rectified (shen.<-out Parseshen.<rules*>))))))) (shen.parse-failure))))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.freshen-sig (V4446) (let Vs (shen.extract-vars V4446) (let Assoc (map (lambda V (cons V (shen.freshterm (concat & V)))) Vs) (shen.freshen-type Assoc V4446))))

(defun shen.freshen-type (V4447 V4448) (cond ((= () V4447) V4448) ((and (cons? V4447) (cons? (hd V4447))) (shen.freshen-type (tl V4447) (subst (tl (hd V4447)) (hd (hd V4447)) V4448))) (true (shen.f-error shen.freshen-type))))

(defun shen.<rules*> (V4449) (let Result (let Parseshen.<rule*> (shen.<rule*> V4449) (if (shen.parse-failure? Parseshen.<rule*>) (shen.parse-failure) (let Parseshen.<rules*> (shen.<rules*> Parseshen.<rule*>) (if (shen.parse-failure? Parseshen.<rules*>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules*>) (cons (shen.linearise (shen.<-out Parseshen.<rule*>)) (shen.<-out Parseshen.<rules*>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<rule*> (shen.<rule*> V4449) (if (shen.parse-failure? Parseshen.<rule*>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rule*>) (cons (shen.linearise (shen.<-out Parseshen.<rule*>)) ())))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<rule*> (V4450) (let Result (let Parseshen.<patterns> (shen.<patterns> V4450) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News4053 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News4053) (let Action (shen.hds News4053) (let News4054 (shen.tls News4053) (if (shen.=hd? News4054 where) (let News4055 (shen.tls News4054) (if (shen.non-empty-stream? News4055) (let Guard (shen.hds News4055) (let News4056 (shen.tls News4055) (shen.comb (shen.in-> News4056) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons Action ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V4450) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News4057 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News4057) (let Action (shen.hds News4057) (let News4058 (shen.tls News4057) (if (shen.=hd? News4058 where) (let News4059 (shen.tls News4058) (if (shen.non-empty-stream? News4059) (let Guard (shen.hds News4059) (let News4060 (shen.tls News4059) (shen.comb (shen.in-> News4060) (@p (shen.<-out Parseshen.<patterns>) (shen.correct (cons where (cons Guard (cons Action ())))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V4450) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News4061 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News4061) (let Action (shen.hds News4061) (let News4062 (shen.tls News4061) (shen.comb (shen.in-> News4062) (@p (shen.<-out Parseshen.<patterns>) (shen.correct Action))))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V4450) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News4063 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News4063) (let Action (shen.hds News4063) (let News4064 (shen.tls News4063) (shen.comb (shen.in-> News4064) (@p (shen.<-out Parseshen.<patterns>) Action)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.correct (V4451) (cond ((and (cons? V4451) (and (= where (hd V4451)) (and (cons? (tl V4451)) (and (cons? (tl (tl V4451))) (and (cons? (hd (tl (tl V4451)))) (and (= fail-if (hd (hd (tl (tl V4451))))) (and (cons? (tl (hd (tl (tl V4451))))) (and (cons? (tl (tl (hd (tl (tl V4451)))))) (and (= () (tl (tl (tl (hd (tl (tl V4451))))))) (= () (tl (tl (tl V4451))))))))))))) (cons where (cons (cons and (cons (hd (tl V4451)) (cons (cons not (cons (tl (hd (tl (tl V4451)))) ())) ()))) (tl (tl (hd (tl (tl V4451)))))))) ((and (cons? V4451) (and (= where (hd V4451)) (and (cons? (tl V4451)) (and (cons? (tl (tl V4451))) (= () (tl (tl (tl V4451)))))))) (cons where (cons (cons and (cons (hd (tl V4451)) (cons (cons not (cons (cons = (cons (hd (tl (tl V4451))) (cons (cons fail ()) ()))) ())) ()))) (tl (tl V4451))))) ((and (cons? V4451) (and (= fail-if (hd V4451)) (and (cons? (tl V4451)) (and (cons? (tl (tl V4451))) (= () (tl (tl (tl V4451)))))))) (cons where (cons (cons not (cons (tl V4451) ())) (tl (tl V4451))))) (true (cons where (cons (cons not (cons (cons = (cons V4451 (cons (cons fail ()) ()))) ())) (cons V4451 ()))))))

(defun shen.t*-rules (V4452 V4453 V4454 V4455 V4456 V4457 V4458 V4459) (let K4067 (+ V4458 1) (let C4073 (if (shen.unlocked? V4457) (let Tm4074 (shen.lazyderef V4453 V4456) (if (= Tm4074 ()) (do (shen.incinfs) (thaw V4459)) false)) false) (if (= C4073 false) (let C4075 (if (shen.unlocked? V4457) (let Tm4076 (shen.lazyderef V4453 V4456) (if (cons? Tm4076) (let Rule (hd Tm4076) (let Rules (tl Tm4076) (let Fresh (shen.newpv V4456) (shen.gc V4456 (do (shen.incinfs) (bind Fresh (shen.freshen-rule (shen.deref Rule V4456)) V4456 V4457 K4067 (freeze (shen.t*-rule V4452 V4455 (fst (shen.lazyderef Fresh V4456)) (snd (shen.lazyderef Fresh V4456)) V4454 V4456 V4457 K4067 (freeze (shen.cut V4456 V4457 K4067 (freeze (shen.t*-rules V4452 Rules V4454 (+ V4455 1) V4456 V4457 K4067 V4459)))))))))))) false)) false) (if (= C4075 false) (shen.unlock V4457 K4067) C4075)) C4073))))

(defun shen.freshen-rule (V4460) (cond ((tuple? V4460) (let Vs (shen.extract-vars (fst V4460)) (let Assoc (map (lambda V (cons V (shen.freshterm V))) Vs) (@p (shen.freshen Assoc (fst V4460)) (shen.freshen Assoc (snd V4460)))))) (true (shen.f-error shen.freshen-rule))))

(defun shen.freshen (V4461 V4462) (cond ((= () V4461) V4462) ((and (cons? V4461) (cons? (hd V4461))) (shen.freshen (tl V4461) (shen.beta (hd (hd V4461)) (tl (hd V4461)) V4462))) (true (shen.f-error shen.freshen))))

(defun shen.t*-rule (V4463 V4464 V4465 V4466 V4467 V4468 V4469 V4470 V4471) (let C4086 (if (shen.unlocked? V4469) (do (shen.incinfs) (shen.t*-rule-h V4465 V4466 V4467 V4468 V4469 V4470 V4471)) false) (if (= C4086 false) (if (shen.unlocked? V4469) (let Err (shen.newpv V4468) (shen.gc V4468 (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app V4464 (cn " of " (shen.app V4463 "
" shen.a)) shen.a))) V4468 V4469 V4470 V4471)))) false) C4086)))

(defun shen.t*-rule-h (V4472 V4473 V4474 V4475 V4476 V4477 V4478) (let K4089 (+ V4477 1) (let C4094 (if (shen.unlocked? V4476) (let Tm4095 (shen.lazyderef V4472 V4475) (if (= Tm4095 ()) (let Tm4096 (shen.lazyderef V4474 V4475) (if (cons? Tm4096) (let Tm4097 (shen.lazyderef (hd Tm4096) V4475) (if (= Tm4097 -->) (let Tm4098 (shen.lazyderef (tl Tm4096) V4475) (if (cons? Tm4098) (let A (hd Tm4098) (let Tm4099 (shen.lazyderef (tl Tm4098) V4475) (if (= Tm4099 ()) (do (shen.incinfs) (shen.cut V4475 V4476 K4089 (freeze (shen.t*-correct V4473 A () V4475 V4476 K4089 V4478)))) false))) false)) false)) false)) false)) false) (if (= C4094 false) (let C4100 (if (shen.unlocked? V4476) (let B (shen.newpv V4475) (shen.gc V4475 (let Hyps (shen.newpv V4475) (shen.gc V4475 (do (shen.incinfs) (shen.t*-integrity V4472 V4474 Hyps B V4475 V4476 K4089 (freeze (shen.cut V4475 V4476 K4089 (freeze (shen.t*-correct V4473 B Hyps V4475 V4476 K4089 V4478)))))))))) false) (if (= C4100 false) (shen.unlock V4476 K4089) C4100)) C4094))))

(defun shen.t*-correct (V4479 V4480 V4481 V4482 V4483 V4484 V4485) (let K4103 (+ V4484 1) (let C4108 (if (shen.unlocked? V4483) (let Tm4109 (shen.lazyderef V4479 V4482) (if (cons? Tm4109) (let Tm4110 (shen.lazyderef (hd Tm4109) V4482) (if (= Tm4110 where) (let Tm4111 (shen.lazyderef (tl Tm4109) V4482) (if (cons? Tm4111) (let G (hd Tm4111) (let Tm4112 (shen.lazyderef (tl Tm4111) V4482) (if (cons? Tm4112) (let R (hd Tm4112) (let Tm4113 (shen.lazyderef (tl Tm4112) V4482) (if (= Tm4113 ()) (let CurryG (shen.newpv V4482) (shen.gc V4482 (do (shen.incinfs) (shen.cut V4482 V4483 K4103 (freeze (bind CurryG (shen.curry G) V4482 V4483 K4103 (freeze (shen.system-S-h CurryG boolean V4481 V4482 V4483 K4103 (freeze (shen.cut V4482 V4483 K4103 (freeze (shen.t*-correct R V4480 (cons (cons CurryG (cons (intern ":") (cons verified ()))) V4481) V4482 V4483 K4103 V4485)))))))))))) false))) false))) false)) false)) false)) false) (if (= C4108 false) (let C4114 (if (shen.unlocked? V4483) (do (shen.incinfs) (shen.system-S-h (shen.curry V4479) V4480 V4481 V4482 V4483 K4103 V4485)) false) (if (= C4114 false) (shen.unlock V4483 K4103) C4114)) C4108))))

(defun shen.t*-integrity (V4486 V4487 V4488 V4489 V4490 V4491 V4492 V4493) (let K4118 (+ V4492 1) (let C4124 (if (shen.unlocked? V4491) (let Tm4125 (shen.lazyderef V4486 V4490) (if (= Tm4125 ()) (let Tm4126 (shen.lazyderef V4488 V4490) (let GoTo4127 (freeze (do (shen.incinfs) (is! V4487 V4489 V4490 V4491 K4118 V4493))) (if (= Tm4126 ()) (thaw GoTo4127) (if (shen.pvar? Tm4126) (shen.bind! Tm4126 () V4490 GoTo4127) false)))) false)) false) (if (= C4124 false) (let C4128 (if (shen.unlocked? V4491) (let Tm4129 (shen.lazyderef V4486 V4490) (if (cons? Tm4129) (let P (hd Tm4129) (let Ps (tl Tm4129) (let Tm4130 (shen.lazyderef V4487 V4490) (if (cons? Tm4130) (let A (hd Tm4130) (let Tm4131 (shen.lazyderef (tl Tm4130) V4490) (if (cons? Tm4131) (let Tm4132 (shen.lazyderef (hd Tm4131) V4490) (if (= Tm4132 -->) (let Tm4133 (shen.lazyderef (tl Tm4131) V4490) (if (cons? Tm4133) (let B (hd Tm4133) (let Tm4134 (shen.lazyderef (tl Tm4133) V4490) (if (= Tm4134 ()) (let Tm4135 (shen.lazyderef V4488 V4490) (let GoTo4136 (lambda Hyp (lambda Hyps (let PHyps (shen.newpv V4490) (shen.gc V4490 (do (shen.incinfs) (bind Hyp (cons P (cons (intern ":") (cons A ()))) V4490 V4491 K4118 (freeze (shen.p-hyps P PHyps V4490 V4491 K4118 (freeze (shen.cut V4490 V4491 K4118 (freeze (shen.system-S-h P A PHyps V4490 V4491 K4118 (freeze (shen.cut V4490 V4491 K4118 (freeze (shen.t*-integrity Ps B Hyps V4489 V4490 V4491 K4118 V4493)))))))))))))))) (if (cons? Tm4135) (let Hyp (hd Tm4135) (let Hyps (tl Tm4135) ((GoTo4136 Hyp) Hyps))) (if (shen.pvar? Tm4135) (let Hyp (shen.newpv V4490) (shen.gc V4490 (let Hyps (shen.newpv V4490) (shen.gc V4490 (shen.bind! Tm4135 (cons Hyp Hyps) V4490 (freeze ((GoTo4136 Hyp) Hyps))))))) false)))) false))) false)) false)) false))) false)))) false)) false) (if (= C4128 false) (shen.unlock V4491 K4118) C4128)) C4124))))

(defun shen.p-hyps (V4494 V4495 V4496 V4497 V4498 V4499) (let K4139 (+ V4498 1) (let C4143 (if (shen.unlocked? V4497) (let A (shen.newpv V4496) (shen.gc V4496 (do (shen.incinfs) (when (shen.freshterm? (shen.deref V4494 V4496)) V4496 V4497 K4139 (freeze (shen.cut V4496 V4497 K4139 (freeze (bind V4495 (cons (cons V4494 (cons (intern ":") (cons A ()))) ()) V4496 V4497 K4139 V4499)))))))) false) (if (= C4143 false) (let C4144 (if (shen.unlocked? V4497) (let Tm4145 (shen.lazyderef V4494 V4496) (if (cons? Tm4145) (let X (hd Tm4145) (let Y (tl Tm4145) (let XHyps (shen.newpv V4496) (shen.gc V4496 (let YHyps (shen.newpv V4496) (shen.gc V4496 (do (shen.incinfs) (shen.cut V4496 V4497 K4139 (freeze (shen.p-hyps X XHyps V4496 V4497 K4139 (freeze (shen.p-hyps Y YHyps V4496 V4497 K4139 (freeze (shen.join XHyps YHyps V4495 V4496 V4497 K4139 V4499)))))))))))))) false)) false) (if (= C4144 false) (let C4146 (if (shen.unlocked? V4497) (do (shen.incinfs) (bind V4495 () V4496 V4497 K4139 V4499)) false) (if (= C4146 false) (shen.unlock V4497 K4139) C4146)) C4144)) C4143))))

(defun shen.freshterm? (V4500) (and (absvector? V4500) (and (not (string? V4500)) (= (<-address V4500 0) shen.print-freshterm))))

(defun shen.join (V4501 V4502 V4503 V4504 V4505 V4506 V4507) (let C4154 (if (shen.unlocked? V4505) (let Tm4155 (shen.lazyderef V4501 V4504) (if (= Tm4155 ()) (do (shen.incinfs) (bind V4503 V4502 V4504 V4505 V4506 V4507)) false)) false) (if (= C4154 false) (if (shen.unlocked? V4505) (let Tm4156 (shen.lazyderef V4501 V4504) (if (cons? Tm4156) (let X (hd Tm4156) (let Y (tl Tm4156) (let Tm4157 (shen.lazyderef V4503 V4504) (let GoTo4158 (lambda X* (lambda Z (do (shen.incinfs) (bind X* X V4504 V4505 V4506 (freeze (shen.join Y V4502 Z V4504 V4505 V4506 V4507)))))) (if (cons? Tm4157) (let X* (hd Tm4157) (let Z (tl Tm4157) ((GoTo4158 X*) Z))) (if (shen.pvar? Tm4157) (let X* (shen.newpv V4504) (shen.gc V4504 (let Z (shen.newpv V4504) (shen.gc V4504 (shen.bind! Tm4157 (cons X* Z) V4504 (freeze ((GoTo4158 X*) Z))))))) false)))))) false)) false) C4154)))

