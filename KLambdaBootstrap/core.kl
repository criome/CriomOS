(defun shen.shen->kl (V1502) (let KL (shen.shen->kl-h V1502) (shen.record-and-evaluate KL)))

(defun shen.record-and-evaluate (V1503) (cond ((and (cons? V1503) (and (= defun (hd V1503)) (and (cons? (tl V1503)) (and (cons? (tl (tl V1503))) (and (cons? (tl (tl (tl V1503)))) (= () (tl (tl (tl (tl V1503)))))))))) (let SysfuncChk (if (shen.sysfunc? (hd (tl V1503))) (simple-error (shen.app (hd (tl V1503)) " is not a legitimate function name
" shen.a)) shen.skip) (let Arity (shen.store-arity (hd (tl V1503)) (length (hd (tl (tl V1503))))) (let Record (shen.record-kl (hd (tl V1503)) V1503) (let Eval (eval-kl V1503) (shen.fn-print (hd (tl V1503)))))))) (true V1503)))

(defun shen.shen->kl-h (V1504) (cond ((and (cons? V1504) (and (= define (hd V1504)) (cons? (tl V1504)))) (shen.shendef->kldef (hd (tl V1504)) (tl (tl V1504)))) ((and (cons? V1504) (and (= defun (hd V1504)) (and (cons? (tl V1504)) (and (cons? (tl (tl V1504))) (and (cons? (tl (tl (tl V1504)))) (= () (tl (tl (tl (tl V1504)))))))))) V1504) ((and (cons? V1504) (and (= type (hd V1504)) (and (cons? (tl V1504)) (and (cons? (tl (tl V1504))) (= () (tl (tl (tl V1504)))))))) (cons type (cons (hd (tl V1504)) (cons (shen.rcons_form (hd (tl (tl V1504)))) ())))) ((and (cons? V1504) (and (= input+ (hd V1504)) (and (cons? (tl V1504)) (and (cons? (tl (tl V1504))) (= () (tl (tl (tl V1504)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V1504))) (tl (tl V1504))))) ((cons? V1504) (map (lambda Z (shen.shen->kl-h Z)) V1504)) (true V1504)))

(defun shen.shendef->kldef (V1505 V1506) (compile (lambda X (shen.<define> X)) (cons V1505 V1506)))

(defun shen.<define> (V1507) (let Result (let Parseshen.<name> (shen.<name> V1507) (if (shen.parse-failure? Parseshen.<name>) (shen.parse-failure) (if (shen.=hd? Parseshen.<name> {) (let News1367 (shen.tls Parseshen.<name>) (let Parseshen.<signature> (shen.<signature> News1367) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (shen.=hd? Parseshen.<signature> }) (let News1368 (shen.tls Parseshen.<signature>) (let Parseshen.<rules> (shen.<rules> News1368) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (shen.shendef->kldef-h (shen.<-out Parseshen.<name>) (shen.<-out Parseshen.<rules>)))))) (shen.parse-failure))))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<name> (shen.<name> V1507) (if (shen.parse-failure? Parseshen.<name>) (shen.parse-failure) (let Parseshen.<rules> (shen.<rules> Parseshen.<name>) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (shen.shendef->kldef-h (shen.<-out Parseshen.<name>) (shen.<-out Parseshen.<rules>))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.shendef->kldef-h (V1508 V1509) (let Ps (map (lambda X (fst X)) V1509) (let Arity (shen.arity-chk V1508 Ps) (let FreeVarChk (map (lambda R (shen.free-var-chk V1508 R)) V1509) (let Unprotect (shen.unprotect V1509) (let KL (shen.factorise-code (shen.compile-to-kl V1508 Unprotect Arity)) KL))))))

(defun shen.unprotect (V1510) (cond ((tuple? V1510) (@p (shen.unprotect (fst V1510)) (shen.unprotect (snd V1510)))) ((and (cons? V1510) (and (= protect (hd V1510)) (and (cons? (tl V1510)) (= () (tl (tl V1510)))))) (shen.unprotect (hd (tl V1510)))) ((cons? V1510) (map (lambda Z (shen.unprotect Z)) V1510)) (true V1510)))

(defun shen.<name> (V1511) (let Result (if (shen.non-empty-stream? V1511) (let X (shen.hds V1511) (let News1370 (shen.tls V1511) (shen.comb (shen.in-> News1370) (if (and (symbol? X) (not (variable? X))) X (simple-error (shen.app X " is not a legitimate function name.
" shen.a)))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<signature> (V1512) (let Result (if (shen.non-empty-stream? V1512) (let X (shen.hds V1512) (let News1372 (shen.tls V1512) (let Parseshen.<signature> (shen.<signature> News1372) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (not (element? X (cons { (cons } ())))) (shen.comb (shen.in-> Parseshen.<signature>) (cons X (shen.<-out Parseshen.<signature>))) (shen.parse-failure)))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V1512) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<rules> (V1513) (let Result (let Parseshen.<rule> (shen.<rule> V1513) (if (shen.parse-failure? Parseshen.<rule>) (shen.parse-failure) (let Parseshen.<rules> (shen.<rules> Parseshen.<rule>) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (cons (shen.linearise (shen.<-out Parseshen.<rule>)) (shen.<-out Parseshen.<rules>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<!> (<!> V1513) (if (shen.parse-failure? Parse<!>) (shen.parse-failure) (shen.comb (shen.in-> Parse<!>) (if (empty? (shen.<-out Parse<!>)) () (simple-error (cn "Shen syntax error here:
 " (shen.app (shen.<-out Parse<!>) "
 ..." shen.r))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.linearise (V1516) (cond ((tuple? V1516) (shen.linearise-h (fst V1516) (fst V1516) () (snd V1516))) (true (simple-error "implementation error in shen.linearise"))))

(defun shen.linearise-h (V1529 V1530 V1531 V1532) (cond ((= () V1529) (@p V1530 V1532)) ((and (cons? V1529) (cons? (hd V1529))) (shen.linearise-h (append (hd V1529) (tl V1529)) V1530 V1531 V1532)) ((and (cons? V1529) (variable? (hd V1529))) (if (element? (hd V1529) V1531) (let Z (gensym V) (shen.linearise-h (tl V1529) (shen.rep-X (hd V1529) Z V1530) V1531 (cons where (cons (cons = (cons Z (cons (hd V1529) ()))) (cons V1532 ()))))) (shen.linearise-h (tl V1529) V1530 (cons (hd V1529) V1531) V1532))) ((cons? V1529) (shen.linearise-h (tl V1529) V1530 V1531 V1532)) (true (simple-error "implementation error in shen.linearise-h"))))

(defun shen.<rule> (V1533) (let Result (let Parseshen.<patterns> (shen.<patterns> V1533) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News1375 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News1375) (let Action (shen.hds News1375) (let News1376 (shen.tls News1375) (if (shen.=hd? News1376 where) (let News1377 (shen.tls News1376) (if (shen.non-empty-stream? News1377) (let Guard (shen.hds News1377) (let News1378 (shen.tls News1377) (shen.comb (shen.in-> News1378) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons Action ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V1533) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News1379 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News1379) (let Action (shen.hds News1379) (let News1380 (shen.tls News1379) (shen.comb (shen.in-> News1380) (@p (shen.<-out Parseshen.<patterns>) Action)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V1533) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News1381 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News1381) (let Action (shen.hds News1381) (let News1382 (shen.tls News1381) (if (shen.=hd? News1382 where) (let News1383 (shen.tls News1382) (if (shen.non-empty-stream? News1383) (let Guard (shen.hds News1383) (let News1384 (shen.tls News1383) (shen.comb (shen.in-> News1384) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons (cons shen.choicepoint! (cons Action ())) ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V1533) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News1385 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News1385) (let Action (shen.hds News1385) (let News1386 (shen.tls News1385) (shen.comb (shen.in-> News1386) (@p (shen.<-out Parseshen.<patterns>) (cons shen.choicepoint! (cons Action ())))))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.<patterns> (V1534) (let Result (let Parseshen.<pattern> (shen.<pattern> V1534) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (let Parseshen.<patterns> (shen.<patterns> Parseshen.<pattern>) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<patterns>) (cons (shen.<-out Parseshen.<pattern>) (shen.<-out Parseshen.<patterns>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V1534) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<pattern> (V1535) (let Result (if (shen.ccons? V1535) (let SynCons (shen.comb (shen.hds V1535) (shen.<-out V1535)) (let Parseshen.<constructor> (shen.<constructor> SynCons) (if (shen.parse-failure? Parseshen.<constructor>) (shen.parse-failure) (let Parseshen.<pattern1> (shen.<pattern1> Parseshen.<constructor>) (if (shen.parse-failure? Parseshen.<pattern1>) (shen.parse-failure) (let Parseshen.<pattern2> (shen.<pattern2> Parseshen.<pattern1>) (if (shen.parse-failure? Parseshen.<pattern2>) (shen.parse-failure) (let Parseshen.<end> (shen.<end> Parseshen.<pattern2>) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V1535)) (cons (shen.<-out Parseshen.<constructor>) (cons (shen.<-out Parseshen.<pattern1>) (cons (shen.<-out Parseshen.<pattern2>) ()))))))))))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.ccons? V1535) (let SynCons (shen.comb (shen.hds V1535) (shen.<-out V1535)) (if (shen.=hd? SynCons vector) (let News1389 (shen.tls SynCons) (if (shen.=hd? News1389 0) (let News1390 (shen.tls News1389) (let Parseshen.<end> (shen.<end> News1390) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V1535)) (cons vector (cons 0 ())))))) (shen.parse-failure))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V1535) (let X (shen.hds V1535) (let News1391 (shen.tls V1535) (if (cons? X) (shen.comb (shen.in-> News1391) (shen.constructor-error X)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (let Parseshen.<simple-pattern> (shen.<simple-pattern> V1535) (if (shen.parse-failure? Parseshen.<simple-pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<simple-pattern>) (shen.<-out Parseshen.<simple-pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.<constructor> (V1536) (let Result (if (shen.non-empty-stream? V1536) (let C (shen.hds V1536) (let News1393 (shen.tls V1536) (if (shen.constructor? C) (shen.comb (shen.in-> News1393) C) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.constructor? (V1537) (element? V1537 (cons cons (cons @p (cons @s (cons @v ()))))))

(defun shen.constructor-error (V1538) (simple-error (shen.app V1538 " is not a legitimate constructor
" shen.r)))

(defun shen.<simple-pattern> (V1539) (let Result (if (shen.non-empty-stream? V1539) (let X (shen.hds V1539) (let News1395 (shen.tls V1539) (if (= X _) (shen.comb (shen.in-> News1395) (gensym Y)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V1539) (let X (shen.hds V1539) (let News1396 (shen.tls V1539) (if (not (element? X (cons -> (cons <- ())))) (shen.comb (shen.in-> News1396) X) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<pattern1> (V1540) (let Result (let Parseshen.<pattern> (shen.<pattern> V1540) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<pattern>) (shen.<-out Parseshen.<pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<pattern2> (V1541) (let Result (let Parseshen.<pattern> (shen.<pattern> V1541) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<pattern>) (shen.<-out Parseshen.<pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.fn-print (V1542) (let V (absvector 2) (let Print (address-> V 0 shen.printF) (let Named (address-> Print 1 (@s "(" (@s "f" (@s "n" (@s " " (@s (str V1542) ")")))))) Named))))

(defun shen.printF (V1543) (<-address V1543 1))

(defun shen.arity-chk (V1548 V1549) (cond ((and (cons? V1549) (= () (tl V1549))) (length (hd V1549))) ((and (cons? V1549) (and (cons? (tl V1549)) (= (length (hd V1549)) (length (hd (tl V1549)))))) (shen.arity-chk V1548 (tl V1549))) (true (simple-error (cn "arity error in " (shen.app V1548 "
" shen.a))))))

(defun shen.free-var-chk (V1550 V1551) (cond ((tuple? V1551) (shen.free-variable-error-message V1550 (shen.find-free-vars (shen.extract-vars (fst V1551)) (snd V1551)))) (true (shen.f-error shen.free-var-chk))))

(defun shen.free-variable-error-message (V1552 V1553) (if (empty? V1553) shen.skip (do (pr (cn "free variables in " (shen.app V1552 ":" shen.a)) (stoutput)) (do (map (lambda X (pr (cn " " (shen.app X "" shen.a)) (stoutput))) V1553) (do (nl 1) (abort))))))

(defun shen.extract-vars (V1556) (cond ((variable? V1556) (cons V1556 ())) ((cons? V1556) (union (shen.extract-vars (hd V1556)) (shen.extract-vars (tl V1556)))) (true ())))

(defun shen.find-free-vars (V1561 V1562) (cond ((and (cons? V1562) (and (= protect (hd V1562)) (and (cons? (tl V1562)) (= () (tl (tl V1562)))))) ()) ((and (cons? V1562) (and (= let (hd V1562)) (and (cons? (tl V1562)) (and (cons? (tl (tl V1562))) (and (cons? (tl (tl (tl V1562)))) (= () (tl (tl (tl (tl V1562)))))))))) (union (shen.find-free-vars V1561 (hd (tl (tl V1562)))) (shen.find-free-vars (cons (hd (tl V1562)) V1561) (hd (tl (tl (tl V1562))))))) ((and (cons? V1562) (and (= lambda (hd V1562)) (and (cons? (tl V1562)) (and (cons? (tl (tl V1562))) (= () (tl (tl (tl V1562)))))))) (shen.find-free-vars (cons (hd (tl V1562)) V1561) (hd (tl (tl V1562))))) ((cons? V1562) (union (shen.find-free-vars V1561 (hd V1562)) (shen.find-free-vars V1561 (tl V1562)))) ((shen.free-variable? V1562 V1561) (cons V1562 ())) (true ())))

(defun shen.free-variable? (V1563 V1564) (and (variable? V1563) (not (element? V1563 V1564))))

(defun shen.record-kl (V1565 V1566) (put V1565 shen.source V1566 (value *property-vector*)))

(defun shen.compile-to-kl (V1567 V1568 V1569) (let Parameters (shen.parameters V1569) (let Body (shen.scan-body V1567 (shen.kl-body V1568 Parameters)) (let Defun (cons defun (cons V1567 (cons Parameters (cons (shen.cond-form Body) ())))) Defun))))

(defun shen.parameters (V1570) (cond ((= 0 V1570) ()) (true (cons (gensym V) (shen.parameters (- V1570 1))))))

(defun shen.cond-form (V1573) (cond ((and (cons? V1573) (and (cons? (hd V1573)) (and (= true (hd (hd V1573))) (and (cons? (tl (hd V1573))) (= () (tl (tl (hd V1573)))))))) (hd (tl (hd V1573)))) (true (cons cond V1573))))

(defun shen.scan-body (V1582 V1583) (cond ((= () V1583) (cons (cons true (cons (cons shen.f-error (cons V1582 ())) ())) ())) ((and (cons? V1583) (shen.choicepoint? (hd V1583))) (shen.choicepoint V1582 (gensym Freeze) (gensym Result) (hd V1583) (tl V1583))) ((and (cons? V1583) (and (cons? (hd V1583)) (and (= true (hd (hd V1583))) (and (cons? (tl (hd V1583))) (= () (tl (tl (hd V1583)))))))) (cons (hd V1583) ())) ((cons? V1583) (cons (hd V1583) (shen.scan-body V1582 (tl V1583)))) (true (simple-error "implementation error in shen.scan-body"))))

(defun shen.choicepoint? (V1590) (cond ((and (cons? V1590) (and (cons? (tl V1590)) (and (cons? (hd (tl V1590))) (and (= shen.choicepoint! (hd (hd (tl V1590)))) (and (cons? (tl (hd (tl V1590)))) (and (= () (tl (tl (hd (tl V1590))))) (= () (tl (tl V1590))))))))) true) (true false)))

(defun shen.choicepoint (V1606 V1607 V1608 V1609 V1610) (cond ((and (cons? V1609) (and (cons? (tl V1609)) (and (cons? (hd (tl V1609))) (and (cons? (tl (hd (tl V1609)))) (and (cons? (hd (tl (hd (tl V1609))))) (and (= fail-if (hd (hd (tl (hd (tl V1609)))))) (and (cons? (tl (hd (tl (hd (tl V1609)))))) (and (cons? (tl (tl (hd (tl (hd (tl V1609))))))) (and (= () (tl (tl (tl (hd (tl (hd (tl V1609)))))))) (and (= () (tl (tl (hd (tl V1609))))) (and (= () (tl (tl V1609))) (= V1606 (hd (tl (hd (tl (hd (tl V1609)))))))))))))))))) (cons (cons true (cons (cons let (cons V1607 (cons (cons freeze (cons (cons cond (shen.scan-body (hd (tl (hd (tl (hd (tl V1609)))))) V1610)) ())) (cons (cons if (cons (hd V1609) (cons (cons let (cons V1608 (cons (hd (tl (tl (hd (tl (hd (tl V1609))))))) (cons (cons if (cons (cons (hd (tl (hd (tl (hd (tl V1609)))))) (cons V1608 ())) (cons (cons thaw (cons V1607 ())) (cons V1608 ())))) ())))) (cons (cons thaw (cons V1607 ())) ())))) ())))) ())) ())) ((and (cons? V1609) (and (cons? (tl V1609)) (and (cons? (hd (tl V1609))) (and (cons? (tl (hd (tl V1609)))) (and (= () (tl (tl (hd (tl V1609))))) (= () (tl (tl V1609)))))))) (cons (cons true (cons (cons let (cons V1607 (cons (cons freeze (cons (cons cond (shen.scan-body V1606 V1610)) ())) (cons (cons if (cons (hd V1609) (cons (cons let (cons V1608 (cons (hd (tl (hd (tl V1609)))) (cons (cons if (cons (cons = (cons V1608 (cons (cons fail ()) ()))) (cons (cons thaw (cons V1607 ())) (cons V1608 ())))) ())))) (cons (cons thaw (cons V1607 ())) ())))) ())))) ())) ())) (true (simple-error "implementation error in shen.choicepoint"))))

(defun shen.rep-X (V1612 V1613 V1614) (cond ((= V1612 V1614) V1613) ((cons? V1614) (let Rep (shen.rep-X V1612 V1613 (hd V1614)) (if (= Rep (hd V1614)) (cons (hd V1614) (shen.rep-X V1612 V1613 (tl V1614))) (cons Rep (tl V1614))))) (true V1614)))

(defun shen.kl-body (V1615 V1616) (map (lambda R (shen.triple-stack () (fst R) V1616 (snd R))) V1615))

(defun shen.triple-stack (V1625 V1626 V1627 V1628) (cond ((and (= () V1626) (and (= () V1627) (and (cons? V1628) (and (= where (hd V1628)) (and (cons? (tl V1628)) (and (cons? (tl (tl V1628))) (= () (tl (tl (tl V1628)))))))))) (shen.triple-stack (cons (hd (tl V1628)) V1625) () () (hd (tl (tl V1628))))) ((and (= () V1626) (= () V1627)) (cons (shen.rectify-test (reverse V1625)) (cons V1628 ()))) ((and (cons? V1626) (and (cons? V1627) (variable? (hd V1626)))) (shen.triple-stack V1625 (tl V1626) (tl V1627) (shen.beta (hd V1626) (hd V1627) V1628))) ((and (cons? V1626) (and (cons? (hd V1626)) (and (cons? (tl (hd V1626))) (and (cons? (tl (tl (hd V1626)))) (and (= () (tl (tl (tl (hd V1626))))) (cons? V1627)))))) (shen.triple-stack (cons (cons (shen.op-test (hd (hd V1626))) (cons (hd V1627) ())) V1625) (cons (hd (tl (hd V1626))) (cons (hd (tl (tl (hd V1626)))) (tl V1626))) (cons (cons (shen.op1 (hd (hd V1626))) (cons (hd V1627) ())) (cons (cons (shen.op2 (hd (hd V1626))) (cons (hd V1627) ())) (tl V1627))) (shen.beta (hd V1626) (hd V1627) V1628))) ((and (cons? V1626) (cons? V1627)) (shen.triple-stack (cons (cons = (cons (hd V1626) (cons (hd V1627) ()))) V1625) (tl V1626) (tl V1627) V1628)) (true (simple-error "implementation error in shen.triple-stack"))))

(defun shen.rectify-test (V1631) (cond ((= () V1631) true) ((and (cons? V1631) (= () (tl V1631))) (hd V1631)) ((and (cons? V1631) (cons? (tl V1631))) (cons and (cons (hd V1631) (cons (shen.rectify-test (tl V1631)) ())))) (true (simple-error "implementation error in shen.rectify-test"))))

(defun shen.beta (V1641 V1642 V1643) (cond ((= V1641 V1643) V1642) ((and (cons? V1643) (and (= lambda (hd V1643)) (and (cons? (tl V1643)) (and (cons? (tl (tl V1643))) (and (= () (tl (tl (tl V1643)))) (= V1641 (hd (tl V1643)))))))) V1643) ((and (cons? V1643) (and (= let (hd V1643)) (and (cons? (tl V1643)) (and (cons? (tl (tl V1643))) (and (cons? (tl (tl (tl V1643)))) (and (= () (tl (tl (tl (tl V1643))))) (= V1641 (hd (tl V1643))))))))) (cons let (cons (hd (tl V1643)) (cons (shen.beta (hd (tl V1643)) V1642 (hd (tl (tl V1643)))) (tl (tl (tl V1643))))))) ((cons? V1643) (map (lambda V (shen.beta V1641 V1642 V)) V1643)) (true V1643)))

(defun shen.op1 (V1646) (cond ((= cons V1646) hd) ((= @s V1646) hdstr) ((= @p V1646) fst) ((= @v V1646) hdv) (true (simple-error "implementation error in shen.op1"))))

(defun shen.op2 (V1649) (cond ((= cons V1649) tl) ((= @s V1649) tlstr) ((= @p V1649) snd) ((= @v V1649) tlv) (true (simple-error "implementation error in shen.op2"))))

(defun shen.op-test (V1652) (cond ((= cons V1652) cons?) ((= @s V1652) shen.+string?) ((= @p V1652) tuple?) ((= @v V1652) shen.+vector?) (true (simple-error "implementation error in shen.op-test"))))

(defun shen.+string? (V1653) (cond ((= "" V1653) false) (true (string? V1653))))

(defun shen.+vector? (V1654) (cond ((= V1654 (vector 0)) false) (true (vector? V1654))))

(defun factorise (V1657) (cond ((= + V1657) (set shen.*factorise?* true)) ((= - V1657) (set shen.*factorise?* false)) (true (simple-error "factorise expects a + or a -
"))))

(defun shen.factorise-code (V1658) (cond ((and (cons? V1658) (and (= defun (hd V1658)) (and (cons? (tl V1658)) (and (cons? (tl (tl V1658))) (and (cons? (tl (tl (tl V1658)))) (and (cons? (hd (tl (tl (tl V1658))))) (and (= cond (hd (hd (tl (tl (tl V1658)))))) (and (= () (tl (tl (tl (tl V1658))))) (value shen.*factorise?*))))))))) (cons defun (cons (hd (tl V1658)) (cons (hd (tl (tl V1658))) (cons (shen.vertical (hd (tl (tl V1658))) (tl (hd (tl (tl (tl V1658))))) (cons shen.f-error (cons (hd (tl V1658)) ()))) ()))))) (true V1658)))

(defun shen.vertical (V1671 V1672 V1673) (cond ((and (cons? V1672) (and (cons? (hd V1672)) (and (= true (hd (hd V1672))) (and (cons? (tl (hd V1672))) (= () (tl (tl (hd V1672)))))))) (hd (tl (hd V1672)))) ((= () V1672) V1673) ((and (cons? V1672) (and (cons? (hd V1672)) (and (cons? (hd (hd V1672))) (and (= and (hd (hd (hd V1672)))) (and (cons? (tl (hd (hd V1672)))) (and (cons? (tl (tl (hd (hd V1672))))) (and (= () (tl (tl (tl (hd (hd V1672)))))) (and (cons? (tl (hd V1672))) (= () (tl (tl (hd V1672)))))))))))) (let Before+After (shen.split-cases (hd (tl (hd (hd V1672)))) V1672 ()) (shen.branch (hd (tl (hd (hd V1672)))) V1671 Before+After V1673))) ((and (cons? V1672) (and (cons? (hd V1672)) (and (cons? (tl (hd V1672))) (= () (tl (tl (hd V1672))))))) (cons if (cons (hd (hd V1672)) (cons (hd (tl (hd V1672))) (cons (shen.vertical V1671 (tl V1672) V1673) ()))))) (true (simple-error "implementation error in shen.vertical"))))

(defun shen.split-cases (V1678 V1679 V1680) (cond ((and (cons? V1679) (and (cons? (hd V1679)) (and (cons? (hd (hd V1679))) (and (= and (hd (hd (hd V1679)))) (and (cons? (tl (hd (hd V1679)))) (and (cons? (tl (tl (hd (hd V1679))))) (and (= () (tl (tl (tl (hd (hd V1679)))))) (and (cons? (tl (hd V1679))) (and (= () (tl (tl (hd V1679)))) (= V1678 (hd (tl (hd (hd V1679)))))))))))))) (shen.split-cases (hd (tl (hd (hd V1679)))) (tl V1679) (cons (cons (hd (tl (tl (hd (hd V1679))))) (tl (hd V1679))) V1680))) ((and (cons? V1679) (and (cons? (hd V1679)) (and (cons? (tl (hd V1679))) (and (= () (tl (tl (hd V1679)))) (= V1678 (hd (hd V1679))))))) (shen.split-cases (hd (hd V1679)) (tl V1679) (cons (cons true (tl (hd V1679))) V1680))) (true (cons (reverse V1680) (cons V1679 ())))))

(defun shen.branch (V1681 V1682 V1683 V1684) (cond ((and (cons? V1683) (and (cons? (tl V1683)) (= () (tl (tl V1683))))) (let Else (shen.else V1682 (hd (tl V1683)) V1684) (let Then (shen.then V1681 V1682 (hd V1683) Else) (cons if (cons V1681 (cons Then (cons Else ()))))))) (true (shen.f-error shen.branch))))

(defun shen.else (V1685 V1686 V1687) (let Else (shen.vertical V1685 V1686 V1687) (if (shen.inline? Else) Else (shen.procedure-call V1685 Else))))

(defun shen.procedure-call (V1688 V1689) (let F (gensym shen.else) (let Used (shen.remove-if-unused V1688 V1689) (let KL (cons defun (cons F (cons Used (cons V1689 ())))) (let EvalKL (eval-kl KL) (let Record (shen.record-kl F KL) (cons F Used)))))))

(defun shen.remove-if-unused (V1696 V1697) (cond ((= () V1696) ()) ((cons? V1696) (if (shen.occurs? (hd V1696) V1697) (cons (hd V1696) (shen.remove-if-unused (tl V1696) V1697)) (shen.remove-if-unused (tl V1696) V1697))) (true (simple-error "implementation error in shen.remove-if-unused"))))

(defun shen.then (V1698 V1699 V1700 V1701) (shen.horizontal (shen.selectors V1698 V1700) V1699 V1700 V1701))

(defun shen.horizontal (V1710 V1711 V1712 V1713) (cond ((= () V1710) (shen.vertical V1711 V1712 V1713)) ((cons? V1710) (let V (gensym V) (cons let (cons V (cons (hd V1710) (cons (shen.horizontal (tl V1710) (cons V V1711) (subst V (hd V1710) V1712) V1713) ())))))) (true (simple-error "implementation error in shen.horizontal"))))

(defun shen.selectors (V1718 V1719) (cond ((and (cons? V1718) (and (cons? (tl V1718)) (and (= () (tl (tl V1718))) (shen.constructor? (shen.op (hd V1718)))))) (let Op (shen.op (hd V1718)) (let Hd (cons (shen.op1 Op) (tl V1718)) (let Tl (cons (shen.op2 Op) (tl V1718)) (let RptedHd? (shen.rpted? Hd V1719) (let RptedTl? (shen.rpted? Tl V1719) (if (and RptedHd? RptedTl?) (cons Hd (cons Tl ())) (if RptedHd? (cons Hd ()) (if RptedTl? (cons Tl ()) ()))))))))) (true ())))

(defun shen.rpted? (V1720 V1721) (> (occurrences V1720 V1721) 1))

(defun shen.inline? (V1722) (cond ((cons? V1722) (and (atom? (hd V1722)) (shen.inline? (tl V1722)))) (true (atom? V1722))))

(defun shen.op (V1725) (cond ((= cons? V1725) cons) ((= shen.+string? V1725) @s) ((= shen.+vector? V1725) @v) ((= tuple? V1725) @p) (true shen.skip)))

